"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestFileMetadata = void 0;
const tslib_1 = require("tslib");
const symbols = tslib_1.__importStar(require("../symbols"));
const BaseMetadata_1 = require("./BaseMetadata");
class TestFileMetadata extends BaseMetadata_1.BaseMetadata {
    globalMetadata;
    [symbols.rootDescribeBlock];
    [symbols.lastTestEntry];
    [symbols.reportedTestEntries] = [];
    [symbols.currentMetadata] = this;
    current = this[symbols.context].createMetadataSelector(() => this[symbols.currentMetadata]);
    constructor(context, id, globalMetadata) {
        super(context, id);
        this.globalMetadata = globalMetadata;
    }
    get rootDescribeBlock() {
        return this[symbols.rootDescribeBlock];
    }
    get lastTestEntry() {
        return this[symbols.lastTestEntry];
    }
    [symbols.addDescribeBlock](id) {
        if (this[symbols.rootDescribeBlock]) {
            throw new Error('Unexpected state: root describe block already exists');
        }
        this[symbols.currentMetadata] = this[symbols.rootDescribeBlock] = this[symbols.context].factory.createDescribeBlockMetadata(this, id);
        return this[symbols.rootDescribeBlock];
    }
    [symbols.start]() {
        this[symbols.currentMetadata] = this;
        this[symbols.lastTestEntry] = undefined;
    }
    [symbols.finish]() {
        // Nothing to do yet
    }
    *allDescribeBlocks() {
        if (this[symbols.rootDescribeBlock]) {
            yield this[symbols.rootDescribeBlock];
            yield* this[symbols.rootDescribeBlock].allDescribeBlocks();
        }
    }
    *allTestEntries() {
        if (this[symbols.rootDescribeBlock]) {
            yield* this[symbols.rootDescribeBlock].allTestEntries();
        }
    }
    *allInvocations() {
        if (this[symbols.rootDescribeBlock]) {
            yield* this[symbols.rootDescribeBlock].allInvocations();
        }
    }
    *allTestInvocations() {
        if (this[symbols.rootDescribeBlock]) {
            yield* this[symbols.rootDescribeBlock].allTestInvocations();
        }
    }
    /**
     * A specialized method to access test entries based on Jest's reporting sequence.
     * For internal use only - handles race conditions and inconsistencies in Jest's
     * reporting behavior (particularly with skipped vs. todo tests).
     *
     * @internal
     */
    _getReportedEntryByIndex(index) {
        return this[symbols.reportedTestEntries][index];
    }
}
exports.TestFileMetadata = TestFileMetadata;
//# sourceMappingURL=TestFileMetadata.js.map