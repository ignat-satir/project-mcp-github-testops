// src/FileAllureReader.ts
import fs from "node:fs/promises";
import path from "node:path";
import * as properties from "properties";

// src/errors.ts
function resolveOnError(onError) {
  if (onError === void 0 || onError === "throw") {
    return (e) => {
      throw e;
    };
  } else if (onError === "ignore") {
    return () => {
    };
  } else {
    return onError;
  }
}
var AllureStoreError = class extends Error {
  constructor(message, cause) {
    super(message, { cause });
    this.cause = cause;
    this.name = "AllureStoreError";
  }
};

// src/FileAllureReader.ts
var FileAllureReader = class {
  #resultsDirectory;
  #onError;
  #scanIdsPromise;
  #containerIds;
  #resultIds;
  constructor(config) {
    this.#resultsDirectory = config.resultsDirectory;
    this.#onError = resolveOnError(config.onError || "throw");
  }
  async getContainerIds() {
    if (!this.#scanIdsPromise) {
      this.#scanIdsPromise = this.#scanIds();
    }
    await this.#scanIdsPromise;
    return this.#containerIds || [];
  }
  async getResultIds() {
    if (!this.#scanIdsPromise) {
      this.#scanIdsPromise = this.#scanIds();
    }
    await this.#scanIdsPromise;
    return this.#resultIds || [];
  }
  async readResult(id) {
    const filePath = path.join(this.#resultsDirectory, `${id}-result.json`);
    return this.#parseJSON(filePath);
  }
  async readContainer(id) {
    const filePath = path.join(this.#resultsDirectory, `${id}-container.json`);
    return this.#parseJSON(filePath);
  }
  async readCategories() {
    const filePath = path.join(this.#resultsDirectory, "categories.json");
    return this.#parseJSON(filePath);
  }
  async readEnvironmentInfo() {
    const filePath = path.join(this.#resultsDirectory, "environment.properties");
    const content = await this.#readFileIfExists(filePath);
    if (!content) return null;
    return properties.parse(content, { sections: false, comments: "#", separators: "=", unicode: true });
  }
  async readExecutorInfo() {
    const filePath = path.join(this.#resultsDirectory, "executor.json");
    return this.#parseJSON(filePath);
  }
  /**
   * Helper method to read and parse JSON files.
   */
  async #parseJSON(filePath) {
    try {
      const content = await this.#readFileIfExists(filePath);
      return content ? JSON.parse(content) : null;
    } catch (error) {
      this.#handleError(`Failed to parse JSON file: ${filePath}`, error);
      return null;
    }
  }
  /**
   * Helper method to safely read a file, returning `null` if it doesn't exist.
   */
  async #readFileIfExists(filePath) {
    try {
      return await fs.readFile(filePath, "utf8");
    } catch (error) {
      this.#handleError(`Failed to read file: ${filePath}`, error);
      return null;
    }
  }
  /**
   * Helper method to list the contents of the results directory and cache the IDs.
   */
  async #scanIds() {
    let files = [];
    try {
      files = await fs.readdir(this.#resultsDirectory);
    } catch (error) {
      this.#handleError(`Failed to list directory: ${this.#resultsDirectory}`, error);
      files = [];
    }
    this.#containerIds = files.filter((f) => f.endsWith("-container.json")).map((f) => path.basename(f, "-container.json"));
    this.#resultIds = files.filter((f) => f.endsWith("-result.json")).map((f) => path.basename(f, "-result.json"));
  }
  #handleError(message, cause) {
    this.#onError(new AllureStoreError(message, cause));
  }
};

// src/FileAllureWriter.ts
import fs2 from "node:fs/promises";
import path2 from "node:path";
import * as properties2 from "properties";
var FileAllureWriter = class {
  #config;
  #onError;
  constructor(config) {
    this.#config = config;
    this.#onError = resolveOnError(config.onError || "throw");
  }
  async init() {
    const { resultsDirectory, overwrite } = this.#config;
    try {
      const directoryExists = await fs2.access(resultsDirectory).then(
        () => true,
        // throw if not ENOENT
        (error) => {
          if ((error == null ? void 0 : error.code) !== "ENOENT") throw error;
          return false;
        }
      );
      if (overwrite && directoryExists) {
        await fs2.rm(resultsDirectory, { recursive: true });
      }
      await fs2.mkdir(resultsDirectory, { recursive: true });
    } catch (error) {
      this.#handleError(`Failed to initialize results directory: ${resultsDirectory}`, error);
    }
  }
  async writeCategories(categories) {
    const filePath = this.#buildPath("categories.json");
    try {
      await writeJson(filePath, categories, regexpAwareStringifier);
    } catch (error) {
      this.#handleError(`Failed to write categories: ${filePath}`, error);
    }
  }
  async writeContainer(container) {
    const filePath = this.#buildPath(`${container.uuid}-container.json`);
    try {
      await writeJson(filePath, container);
    } catch (error) {
      this.#handleError(`Failed to write container: ${filePath}`, error);
    }
  }
  async writeEnvironmentInfo(info) {
    const filePath = this.#buildPath("environment.properties");
    try {
      const text = properties2.stringify(info, { unicode: true });
      await fs2.writeFile(filePath, text + "\n");
    } catch (error) {
      this.#handleError(`Failed to write environment info: ${filePath}`, error);
    }
  }
  async writeExecutorInfo(info) {
    const filePath = this.#buildPath("executor.json");
    try {
      await writeJson(filePath, info);
    } catch (error) {
      this.#handleError(`Failed to write executor info: ${filePath}`, error);
    }
  }
  async writeResult(result) {
    const filePath = this.#buildPath(`${result.uuid}-result.json`);
    try {
      await writeJson(filePath, result);
    } catch (error) {
      this.#handleError(`Failed to write result: ${filePath}`, error);
    }
  }
  #buildPath(name) {
    return path2.join(this.#config.resultsDirectory, name);
  }
  #handleError(message, cause) {
    this.#onError(new AllureStoreError(message, cause));
  }
};
async function writeJson(filePath, data, stringifier) {
  const json = JSON.stringify(data, stringifier);
  await fs2.writeFile(filePath, json + "\n");
}
function regexpAwareStringifier(_key, value) {
  return value instanceof RegExp ? value.source : value;
}

// src/AllureStore.ts
var AllureStore = class _AllureStore {
  #reader;
  #writer;
  constructor(config) {
    this.#reader = config.reader;
    this.#writer = config.writer;
  }
  static async fromConfig(config) {
    var _a, _b, _c, _d;
    await Promise.all([(_b = (_a = config.reader).init) == null ? void 0 : _b.call(_a), (_d = (_c = config.writer).init) == null ? void 0 : _d.call(_c)]);
    return new _AllureStore(config);
  }
  static async fromDirectory(resultsDirectory, config = {}) {
    const reader = new FileAllureReader({ resultsDirectory, onError: config.onError });
    const writer = new FileAllureWriter({ resultsDirectory, onError: config.onError, overwrite: config.overwrite });
    return _AllureStore.fromConfig({ reader, writer });
  }
  //#region Reading methods
  async getAllResults() {
    const [containerIds, resultIds] = await Promise.all([
      this.#reader.getContainerIds(),
      this.#reader.getResultIds()
    ]);
    const containerMap = await this.#buildContainerMap(containerIds);
    const rawResults = await Promise.all(resultIds.map((id) => this.#reader.readResult(id)));
    const validResults = rawResults.filter((r) => r != null);
    return validResults.map((result) => this.#mergeContainers(result, containerMap));
  }
  async getLatestResults() {
    const all = await this.getAllResults();
    const map = /* @__PURE__ */ new Map();
    for (const result of all) {
      const existing = map.get(result.historyId);
      if (!existing || result.stop > existing.stop) {
        map.set(result.historyId, result);
      }
    }
    return [...map.values()];
  }
  async getCategories() {
    return this.#reader.readCategories();
  }
  async getEnvironment() {
    return this.#reader.readEnvironmentInfo();
  }
  async getExecutor() {
    return this.#reader.readExecutorInfo();
  }
  async getContainer(id) {
    return this.#reader.readContainer(id);
  }
  async getResult(id) {
    return this.#reader.readResult(id);
  }
  //#endregion
  //#region Writing methods
  async writeCategories(categories) {
    return this.#writer.writeCategories(categories);
  }
  async writeEnvironmentInfo(info) {
    return this.#writer.writeEnvironmentInfo(info);
  }
  async writeExecutorInfo(info) {
    return this.#writer.writeExecutorInfo(info);
  }
  async writeResult(result) {
    return this.#writer.writeResult(result);
  }
  async writeContainer(container) {
    return this.#writer.writeContainer(container);
  }
  //#endregion
  //#region Private helper methods
  async #buildContainerMap(containerIds) {
    const containerMap = /* @__PURE__ */ new Map();
    await Promise.all(
      containerIds.map(async (cid) => {
        const container = await this.#reader.readContainer(cid);
        if (container) {
          containerMap.set(container.uuid, container);
        }
      })
    );
    return containerMap;
  }
  #mergeContainers(result, containerMap) {
    const ancestors = this.#findAncestorContainers(result.uuid, containerMap);
    const merged = { ...result, steps: this.#mergeSteps(result, ancestors) };
    return merged;
  }
  #findAncestorContainers(startId, containerMap) {
    const parentFor = /* @__PURE__ */ new Map();
    for (const container of containerMap.values()) {
      for (const child of container.children) {
        parentFor.set(child, container.uuid);
      }
    }
    const ancestors = [];
    let currentId = startId;
    while (currentId) {
      const parentId = parentFor.get(currentId);
      if (!parentId) break;
      const parentContainer = containerMap.get(parentId);
      if (!parentContainer) break;
      ancestors.push(parentContainer);
      currentId = parentId;
    }
    return ancestors.reverse();
  }
  #mergeSteps(result, ancestors) {
    const beforeSteps = ancestors.flatMap((a) => a.befores ?? []);
    const afterSteps = [...ancestors].reverse().flatMap((a) => a.afters ?? []);
    return [...beforeSteps, ...result.steps ?? [], ...afterSteps];
  }
  //#endregion
};

// src/index.ts
async function fromConfig(options) {
  return AllureStore.fromConfig(options);
}
async function fromDirectory(resultsDirectory, options) {
  return AllureStore.fromDirectory(resultsDirectory, options);
}
export {
  AllureStore,
  FileAllureReader,
  FileAllureWriter,
  fromConfig,
  fromDirectory
};
//# sourceMappingURL=index.mjs.map
