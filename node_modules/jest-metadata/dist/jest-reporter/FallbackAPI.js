"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FallbackAPI = void 0;
const errors_1 = require("../errors");
const utils_1 = require("../utils");
class FallbackAPI {
    globalMetadata;
    eventEmitter;
    _fallbackModes = new Map();
    _cache = new Map();
    _testEntryCounter = new Map();
    _log = utils_1.diagnostics.child({ cat: 'fallback-api', tid: 'jest-metadata-reporter' });
    constructor(globalMetadata, eventEmitter) {
        this.globalMetadata = globalMetadata;
        this.eventEmitter = eventEmitter;
    }
    get enabled() {
        return this._fallbackModes.size > 0 ? this._fallbackModes.values().next().value : true;
    }
    reportTestFile(testFilePath) {
        this.eventEmitter.emit({
            type: 'add_test_file',
            testFilePath,
        });
        return this.globalMetadata.getTestFileMetadata(testFilePath);
    }
    reportTestCase(testFilePath, testCaseResult) {
        const file = this.globalMetadata.getTestFileMetadata(testFilePath);
        const fallbackMode = this._determineFallbackModeStatus(testFilePath, file);
        if (!fallbackMode) {
            const testEntryIndex = this._incrementTestEntryIndex(testFilePath);
            const testEntryMetadata = file._getReportedEntryByIndex(testEntryIndex);
            if (!testEntryMetadata) {
                this._log.error('Failed to get test entry metadata for %j in file: %j', testCaseResult.title, testFilePath);
            }
            return file._getReportedEntryByIndex(testEntryIndex);
        }
        if (!file.rootDescribeBlock) {
            this.eventEmitter.emit({
                type: 'start_describe_definition',
                testFilePath,
                describeId: 'describe_0',
            });
        }
        const rootDescribeBlock = file.rootDescribeBlock;
        const invocations = testCaseResult.invocations ?? 0;
        const nameIdentifier = [
            testFilePath,
            ...testCaseResult.ancestorTitles,
            testCaseResult.title,
        ].join('\u001F');
        if (invocations <= 1) {
            const testId = `test_${rootDescribeBlock.children.length}`;
            this.eventEmitter.emit({
                type: 'add_test',
                testFilePath,
                testId,
            });
            const lastChild = file.lastTestEntry;
            let rotator;
            if (this._cache.has(nameIdentifier)) {
                rotator = this._cache.get(nameIdentifier);
            }
            else {
                rotator = new utils_1.Rotator();
                this._cache.set(nameIdentifier, rotator);
            }
            rotator.add({
                testId,
                testFilePath,
                testEntryMetadata: lastChild,
                testCaseResult: { ...testCaseResult },
            });
            this.eventEmitter.emit({
                type: 'test_start',
                testFilePath,
                testId,
            });
            this.eventEmitter.emit({
                type: this._getCompletionEventType(testCaseResult),
                testFilePath,
                testId,
            });
            return lastChild;
        }
        else {
            const tests = this._cache.get(nameIdentifier);
            const info = tests.find((t) => t.testCaseResult.status === 'failed');
            info.testCaseResult = { ...testCaseResult };
            this.eventEmitter.emit({
                type: 'test_retry',
                testFilePath: info.testFilePath,
                testId: info.testId,
            });
            this.eventEmitter.emit({
                type: 'test_start',
                testFilePath: info.testFilePath,
                testId: info.testId,
            });
            this.eventEmitter.emit({
                type: this._getCompletionEventType(testCaseResult),
                testFilePath: info.testFilePath,
                testId: info.testId,
            });
            return info.testEntryMetadata;
        }
    }
    reportTestFileResult(testFileResult) {
        const { testFilePath, testResults } = testFileResult;
        const file = this.globalMetadata.getTestFileMetadata(testFilePath);
        const fallbackMode = this._determineFallbackModeStatus(testFilePath, file);
        if (!file.rootDescribeBlock) {
            this.eventEmitter.emit({
                type: 'start_describe_definition',
                testFilePath,
                describeId: 'describe_0',
            });
        }
        const rootDescribeBlock = file.rootDescribeBlock;
        if (!fallbackMode) {
            return [...rootDescribeBlock.allTestEntries()];
        }
        for (const rotator of this._cache.values()) {
            rotator.reset();
        }
        const result = [];
        for (const testCaseResult of testResults) {
            const nameId = this._getNameIdentifier(testFilePath, testCaseResult);
            const tests = this._cache.get(nameId);
            const info = tests?.peek();
            if (info && info.testCaseResult.status === testCaseResult.status) {
                result.push(info.testEntryMetadata);
                tests.next();
            }
            else {
                const testId = `test_${rootDescribeBlock.children.length}`;
                this.eventEmitter.emit({
                    type: 'add_test',
                    testFilePath,
                    testId,
                });
                this.eventEmitter.emit({
                    type: 'test_start',
                    testFilePath,
                    testId,
                });
                this.eventEmitter.emit({
                    type: this._getCompletionEventType(testCaseResult),
                    testFilePath,
                    testId,
                });
                result.push(file.lastTestEntry);
            }
        }
        return result;
    }
    _getNameIdentifier(testFilePath, testCaseResult) {
        return [testFilePath, ...testCaseResult.ancestorTitles, testCaseResult.title].join('\u001F');
    }
    _getCompletionEventType(testCaseResult) {
        switch (testCaseResult.status) {
            case 'passed':
            case 'failed': {
                return 'test_done';
            }
            case 'todo': {
                return 'test_todo';
            }
            case 'skipped':
            case 'pending':
            case 'disabled': {
                return 'test_skip';
            }
            default: {
                throw new errors_1.JestMetadataError(`Unexpected test case result status: ${testCaseResult.status}`);
            }
        }
    }
    _incrementTestEntryIndex(testFilePath) {
        const count = this._testEntryCounter.get(testFilePath) ?? 0;
        this._testEntryCounter.set(testFilePath, count + 1);
        return count;
    }
    _determineFallbackModeStatus(testFilePath, file) {
        if (!this._fallbackModes.has(testFilePath)) {
            this._fallbackModes.set(testFilePath, !file.rootDescribeBlock);
        }
        return this._fallbackModes.get(testFilePath);
    }
}
exports.FallbackAPI = FallbackAPI;
//# sourceMappingURL=FallbackAPI.js.map