"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllureRuntimeImplementation = void 0;
const tslib_1 = require("tslib");
const node_util_1 = tslib_1.__importDefault(require("node:util"));
const utils_1 = require("../utils");
const runtimeModules = tslib_1.__importStar(require("./modules"));
class AllureRuntimeImplementation {
    #context;
    #coreModule;
    #basicStepsModule;
    #contentAttachmentsModule;
    #fileAttachmentsModule;
    #stepsDecorator;
    constructor(context) {
        this.#context = context;
        this.#coreModule = runtimeModules.CoreModule.create(context);
        this.#basicStepsModule = runtimeModules.StepsModule.create(context);
        this.#contentAttachmentsModule = runtimeModules.ContentAttachmentsModule.create(context);
        this.#fileAttachmentsModule = runtimeModules.FileAttachmentsModule.create(context);
        this.#stepsDecorator = new runtimeModules.StepsDecorator({
            handlebars: context.handlebars,
            runtime: this,
        });
    }
    $bind = (options) => {
        const { metadata = true, time = false } = options ?? {};
        return new AllureRuntimeImplementation({
            ...this.#context,
            getCurrentMetadata: metadata
                ? (0, utils_1.constant)(this.#context.getCurrentMetadata())
                : this.#context.getCurrentMetadata,
            getNow: time ? (0, utils_1.constant)(this.#context.getNow()) : this.#context.getNow,
        });
    };
    $plug = (callback) => {
        callback({
            runtime: this,
            handlebars: this.#context.handlebars,
            contentAttachmentHandlers: this.#context.contentAttachmentHandlers,
            fileAttachmentHandlers: this.#context.fileAttachmentHandlers,
            inferMimeType: this.#context.inferMimeType,
        });
        return this;
    };
    flush = () => this.#context.flush();
    description = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.description(value);
    };
    descriptionHtml = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.descriptionHtml(value);
    };
    displayName = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.displayName(value);
    };
    fullName = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.fullName(value);
    };
    historyId = (value) => {
        utils_1.typeAssertions.assertPrimitive(value);
        this.#coreModule.historyId(value);
    };
    label = (name, value) => {
        utils_1.typeAssertions.assertString(name, 'name');
        utils_1.typeAssertions.assertString(value, 'value');
        this.#coreModule.label(name, value);
    };
    link = (url, name, type) => {
        utils_1.typeAssertions.assertString(url, 'url');
        if (name != null)
            utils_1.typeAssertions.assertString(name, 'name');
        if (type != null)
            utils_1.typeAssertions.assertString(type, 'type');
        this.#coreModule.link({ name, url, type });
    };
    parameter = (name, value, options) => {
        utils_1.typeAssertions.assertString(name, 'name');
        this.#coreModule.parameter({
            name,
            value: typeof value === 'string' ? value : node_util_1.default.inspect(value),
            ...options,
        });
    };
    parameters = (parameters) => {
        utils_1.typeAssertions.assertNotNullish(parameters);
        for (const [name, value] of Object.entries(parameters)) {
            if (value && typeof value === 'object') {
                const raw = value;
                this.#coreModule.parameter({ ...raw, name });
            }
            else {
                this.parameter(name, value);
            }
        }
    };
    status = (status, statusDetails) => {
        utils_1.typeAssertions.assertStatus(status);
        this.#coreModule.status(status);
        if ((0, utils_1.isObject)(statusDetails)) {
            this.#coreModule.statusDetails(statusDetails);
        }
    };
    statusDetails = (statusDetails) => {
        utils_1.typeAssertions.assertNotNullish(statusDetails);
        this.#coreModule.statusDetails(statusDetails);
    };
    attachment = (name, content, maybeOptions) => {
        utils_1.typeAssertions.assertString(name, 'name');
        utils_1.typeAssertions.assertAttachmentContent(content, 'content');
        const options = typeof maybeOptions === 'string' ? { mimeType: maybeOptions } : maybeOptions;
        return this.#contentAttachmentsModule.attachment(content, {
            ...options,
            name,
        });
    };
    createAttachment = (function_, nameOrOptions) => {
        utils_1.typeAssertions.assertFunction(function_);
        this.#assertNameOrOptions(nameOrOptions);
        const options = typeof nameOrOptions === 'string' ? { name: nameOrOptions } : { ...nameOrOptions };
        return this.#contentAttachmentsModule.createAttachment(function_, options);
    };
    fileAttachment = (filePath, nameOrOptions) => {
        utils_1.typeAssertions.assertString(filePath, 'filePath');
        const options = typeof nameOrOptions === 'string' ? { name: nameOrOptions } : { ...nameOrOptions };
        return this.#fileAttachmentsModule.attachment(filePath, options);
    };
    createFileAttachment = (function_, nameOrOptions) => {
        utils_1.typeAssertions.assertFunction(function_);
        if (nameOrOptions != null) {
            this.#assertNameOrOptions(nameOrOptions);
        }
        const options = typeof nameOrOptions === 'string' ? { name: nameOrOptions } : { ...nameOrOptions };
        return this.#fileAttachmentsModule.createAttachment(function_, options);
    };
    // @ts-expect-error TS2322: too few arguments
    createStep = (nameFormat, maybeParameters, maybeFunction) => {
        utils_1.typeAssertions.assertString(nameFormat, 'nameFormat');
        const function_ = maybeFunction ?? maybeParameters;
        if (typeof function_ !== 'function') {
            throw new TypeError(`Expected a function, got instead: ${node_util_1.default.inspect(function_)}`);
        }
        const userParameters = Array.isArray(maybeParameters) ? maybeParameters : undefined;
        return this.#stepsDecorator.createStep(nameFormat, function_, userParameters);
    };
    step = (name, function_) => {
        utils_1.typeAssertions.assertString(name, 'name');
        utils_1.typeAssertions.assertFunction(function_);
        return this.#basicStepsModule.step(name, function_);
    };
    epic = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('epic', value);
    };
    feature = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('feature', value);
    };
    issue = (name, url) => {
        utils_1.typeAssertions.assertString(name, 'name');
        if (url != null)
            utils_1.typeAssertions.assertString(url, 'url');
        this.#coreModule.link({ name, url: url ?? '', type: 'issue' });
    };
    owner = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('owner', value);
    };
    package = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('package', value);
    };
    parentSuite = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('parentSuite', value);
    };
    severity = (value) => {
        utils_1.typeAssertions.assertSeverity(value);
        this.#coreModule.label('severity', value);
    };
    story = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('story', value);
    };
    subSuite = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('subSuite', value);
    };
    suite = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('suite', value);
    };
    tag = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('tag', value);
    };
    tags = (...values) => {
        for (const [index, value] of values.entries()) {
            utils_1.typeAssertions.assertString(value, `values[${index}]`);
            this.#coreModule.label('tag', value);
        }
    };
    testClass = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('testClass', value);
    };
    testMethod = (value) => {
        utils_1.typeAssertions.assertString(value);
        this.#coreModule.label('testMethod', value);
    };
    thread = (value) => {
        utils_1.typeAssertions.assertPrimitive(value);
        this.#coreModule.label('thread', String(value));
    };
    tms = (name, url) => {
        utils_1.typeAssertions.assertString(name, 'name');
        if (url != null)
            utils_1.typeAssertions.assertString(url, 'url');
        this.#coreModule.link({ name, url: url ?? '', type: 'tms' });
    };
    #assertNameOrOptions = (nameOrOptions) => {
        if (nameOrOptions == null || (typeof nameOrOptions !== 'string' && !(0, utils_1.isObject)(nameOrOptions))) {
            throw new TypeError(`Expected a name format string or attachment options, got instead: ${node_util_1.default.inspect(nameOrOptions)}`);
        }
    };
}
exports.AllureRuntimeImplementation = AllureRuntimeImplementation;
//# sourceMappingURL=AllureRuntimeImplementation.js.map