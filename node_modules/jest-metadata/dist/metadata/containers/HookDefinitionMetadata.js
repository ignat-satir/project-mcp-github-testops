"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HookDefinitionMetadata = void 0;
const tslib_1 = require("tslib");
const symbols = tslib_1.__importStar(require("../symbols"));
const BaseMetadata_1 = require("./BaseMetadata");
class HookDefinitionMetadata extends BaseMetadata_1.BaseMetadata {
    describeBlock;
    hookType;
    invocations = [];
    constructor(context, describeBlock, id, hookType) {
        super(context, id);
        this.describeBlock = describeBlock;
        this.hookType = hookType;
        if (hookType !== 'beforeEach' &&
            hookType !== 'afterEach' &&
            hookType !== 'beforeAll' &&
            hookType !== 'afterAll') {
            throw new TypeError(`Unknown hook type: ${hookType}`);
        }
    }
    [symbols.start]() {
        const file = this.describeBlock.file;
        const parent = file.current.invocationParent;
        if (!parent) {
            throw new Error('Cannot start hook invocation outside of test or describe block');
        }
        const id = this[symbols.id].nest(`${this.invocations.length}`);
        const invocation = this[symbols.context].factory.createHookInvocationMetadata(this, parent, id);
        this.invocations.push(invocation);
        file[symbols.currentMetadata] = invocation;
        const checker = this[symbols.context].checker;
        switch (this.hookType) {
            case 'beforeEach': {
                checker
                    .asTestInvocationMetadata(parent)
                    .beforeEach.push(invocation);
                break;
            }
            case 'afterEach': {
                checker
                    .asTestInvocationMetadata(parent)
                    .afterEach.push(invocation);
                break;
            }
            case 'beforeAll':
            case 'afterAll': {
                checker
                    .asDescribeBlockMetadata(parent)[symbols.pushExecution](invocation);
                break;
            }
        }
        return invocation;
    }
    [symbols.finish]() {
        const file = this.describeBlock.file;
        const lastInvocation = this.invocations[this.invocations.length - 1];
        if (!lastInvocation) {
            throw new Error('Cannot finish hook invocation without starting it');
        }
        file[symbols.currentMetadata] = lastInvocation.parent;
    }
}
exports.HookDefinitionMetadata = HookDefinitionMetadata;
//# sourceMappingURL=HookDefinitionMetadata.js.map