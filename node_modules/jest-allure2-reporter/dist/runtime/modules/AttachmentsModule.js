"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentAttachmentsModule = exports.FileAttachmentsModule = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_util_1 = tslib_1.__importDefault(require("node:util"));
const utils_1 = require("../../utils");
const utils_2 = require("../../utils");
const errors_1 = require("../../errors");
class AttachmentsModule {
    context;
    constructor(context) {
        this.context = context;
    }
    attachment(content, options) {
        if (typeof options.handler === 'string' && !this.context.handlers[options.handler]) {
            throw new errors_1.AllureRuntimeError(`Unknown attachment handler: ${options.handler}`);
        }
        return (0, utils_1.thruMaybePromise)(content, this.#handleAttachment(options));
    }
    createAttachment(function_, options) {
        return (0, utils_2.hijackFunction)(function_, this.#handleAttachment(options));
    }
    #handleAttachment(userOptions) {
        const formatName = this.context.handlebars.compile(userOptions.name ?? 'untitled');
        return (userContent, arguments_) => {
            const handler = this.#resolveHandler(userOptions);
            const name = formatName(arguments_);
            const mimeContext = this._createMimeContext(name, userContent);
            const mimeType = userOptions.mimeType ??
                this.context.inferMimeType(mimeContext) ??
                'application/octet-stream';
            const context = this._createAttachmentContext({
                name,
                mimeType,
                outDir: this.context.outDir,
                sourcePath: mimeContext.sourcePath,
                content: mimeContext.content,
            });
            const pushAttachment = this.#schedulePushAttachment(context);
            return this.context.waitFor(Promise.resolve()
                .then(() => handler(context))
                .then(pushAttachment));
        };
    }
    #resolveHandler(options) {
        const handler = (options.handler ?? 'default');
        return typeof handler === 'function' ? handler : this.context.handlers[handler];
    }
    #schedulePushAttachment(context) {
        const metadata = this.context.metadata.$bind();
        return (destinationPath) => {
            if (destinationPath) {
                metadata.push('attachments', [
                    {
                        name: context.name,
                        source: destinationPath,
                        type: context.mimeType,
                    },
                ]);
            }
            return destinationPath;
        };
    }
}
class FileAttachmentsModule extends AttachmentsModule {
    static create(context) {
        return new FileAttachmentsModule({
            get handlers() {
                return context.fileAttachmentHandlers;
            },
            get handlebars() {
                return context.handlebars;
            },
            get inferMimeType() {
                return context.inferMimeType;
            },
            get metadata() {
                return context.getCurrentMetadata();
            },
            get outDir() {
                const config = context.getReporterConfig();
                return node_path_1.default.join(config.resultsDir, config.attachments.subDir ?? '');
            },
            waitFor: context.enqueueTask,
        });
    }
    _createMimeContext(_name, sourcePath) {
        return { sourcePath };
    }
    _createAttachmentContext(context) {
        // somewhat fragile - relying here on _createMimeContext output
        return { sourcePath: context.sourcePath, ...context };
    }
}
exports.FileAttachmentsModule = FileAttachmentsModule;
class ContentAttachmentsModule extends AttachmentsModule {
    static create(context) {
        return new ContentAttachmentsModule({
            get handlers() {
                return context.contentAttachmentHandlers;
            },
            get handlebars() {
                return context.handlebars;
            },
            get inferMimeType() {
                return context.inferMimeType;
            },
            get metadata() {
                return context.getCurrentMetadata();
            },
            get outDir() {
                const config = context.getReporterConfig();
                return node_path_1.default.join(config.resultsDir, config.attachments.subDir ?? '');
            },
            waitFor: context.enqueueTask,
        });
    }
    _createMimeContext(name, content) {
        let value = content;
        if (typeof content !== 'string' && !Buffer.isBuffer(content) && !ArrayBuffer.isView(content)) {
            value = node_util_1.default.inspect(content);
        }
        return { sourcePath: name, content: value };
    }
    _createAttachmentContext(context) {
        // somewhat fragile - relying here on _createMimeContext output
        return { content: context.content, ...context };
    }
}
exports.ContentAttachmentsModule = ContentAttachmentsModule;
//# sourceMappingURL=AttachmentsModule.js.map