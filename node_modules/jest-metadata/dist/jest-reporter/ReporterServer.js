"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReporterServer = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
// eslint-disable-next-line import/no-internal-modules
const debug_1 = require("jest-environment-emit/debug");
const utils_1 = require("../utils");
const __REPORTER = (0, utils_1.optimizeTracing)((testFilePath, data) => {
    return {
        tid: ['jest-metadata-reporter', testFilePath],
        data,
    };
});
const __FILE = (0, utils_1.optimizeTracing)((cwd, testFilePath) => {
    return node_path_1.default.relative(cwd, testFilePath);
});
/**
 * @implements {import('@jest/reporters').Reporter}
 */
class ReporterServer {
    #log = utils_1.diagnostics.child({ cat: 'reporter', tid: 'jest-metadata-reporter' });
    #associate;
    #fallbackAPI;
    #ipc;
    #rootDir;
    constructor(config) {
        this.#associate = config.associate;
        this.#fallbackAPI = config.fallbackAPI;
        this.#ipc = config.ipc;
        this.#rootDir = config.rootDir;
        // We are memoizing all methods because there might be
        // multiple reporters based on jest-metadata, so we need to
        // make sure that we are calling every method only once per
        // a given test case result.
        //
        // Unfortunately, we can't _simply_ use `memoizeLast` (last arguments call memoization)
        // due to possibility of concurrent reported events from different files interfering
        // with each other.
        const onRunStart = this.onRunStart.bind(this);
        this.onRunStart = (0, utils_1.memoizeLast)(onRunStart);
        const onTestFileStart = this.onTestFileStart.bind(this);
        this.onTestFileStart = (0, utils_1.memoizeArg1)(() => (0, utils_1.memoizeLast)(onTestFileStart));
        const onTestCaseStart = this.onTestCaseStart.bind(this);
        this.onTestCaseStart = (0, utils_1.memoizeArg1)(() => (0, utils_1.memoizeLast)(onTestCaseStart));
        const onTestCaseResult = this.onTestCaseResult.bind(this);
        this.onTestCaseResult = (0, utils_1.memoizeArg1)(() => (0, utils_1.memoizeLast)(onTestCaseResult));
        const onTestFileResult = this.onTestFileResult.bind(this);
        this.onTestFileResult = (0, utils_1.memoizeArg1)(() => (0, utils_1.memoizeLast)(onTestFileResult));
        const onRunComplete = this.onRunComplete.bind(this);
        this.onRunComplete = (0, utils_1.memoizeLast)(onRunComplete);
    }
    async onRunStart() {
        this.#log.debug.begin(__REPORTER(''), 'test run');
        try {
            await this.#ipc.start();
        }
        catch (error) {
            this.#log.error(error, 'Caught unhandled error in onRunStart');
        }
    }
    onTestFileStart(testPath) {
        this.#log.debug.begin(__REPORTER(testPath), __FILE(this.#rootDir, testPath));
        try {
            const testFileMetadata = this.#fallbackAPI.reportTestFile(testPath);
            this.#associate.filePath(testPath, testFileMetadata);
        }
        catch (error) {
            this.#log.error(error, 'Caught unhandled error in onTestFileStart');
        }
    }
    onTestCaseStart(testPath, testCaseStartInfo) {
        this.#log.debug(__REPORTER(testPath, testCaseStartInfo), 'onTestCaseStart');
        // We cannot use the fallback API here because `testCaseStartInfo`
        // does not contain information, whether this is a retry or not.
        // That's why we might end up with multiple test entries for the same test,
        // so better to ignore this event, rather than distort the data.
    }
    onTestCaseResult(testPath, testCaseResult) {
        this.#log.debug(__REPORTER(testPath), 'onTestCaseResult');
        try {
            const lastTestEntry = this.#fallbackAPI.reportTestCase(testPath, testCaseResult);
            this.#associate.testCaseResult(testCaseResult, lastTestEntry);
        }
        catch (error) {
            this.#log.error(error, 'Caught unhandled error in onTestCaseResult');
        }
    }
    onTestFileResult(testPath, testResult) {
        try {
            const allTestEntries = this.#fallbackAPI.reportTestFileResult(testResult);
            const testResults = testResult.testResults;
            for (let i = 0; i < testResults.length; i++) {
                this.#associate.testCaseResult(testResults[i], allTestEntries[i]);
            }
        }
        catch (error) {
            this.#log.error(error, 'Caught unhandled error in onTestFileResult');
        }
        finally {
            this.#log.debug.end(__REPORTER(testPath));
        }
    }
    async onRunComplete() {
        try {
            await this.#ipc.stop();
        }
        catch (error) {
            this.#log.error(error, 'Caught unhandled error in onRunComplete');
        }
        finally {
            this.#log.debug.end(__REPORTER(''));
            if (process.env.JEST_BUNYAMIN_DIR) {
                await new Promise((resolve) => setTimeout(resolve, 1000));
                await (0, debug_1.aggregateLogs)();
            }
        }
    }
}
exports.ReporterServer = ReporterServer;
//# sourceMappingURL=ReporterServer.js.map