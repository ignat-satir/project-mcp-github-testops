"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryMetadata = void 0;
const errors_1 = require("../errors");
const _associate = Symbol('associate');
const _checker = Symbol('checker');
class QueryMetadata {
    [_associate];
    [_checker];
    constructor(associate, checker) {
        this[_associate] = associate;
        this[_checker] = checker;
    }
    filePath(filePath) {
        if (!filePath) {
            throw new errors_1.JestMetadataError('Cannot query metadata for an empty file path');
        }
        const metadata = this[_associate].get(filePath);
        return this[_checker].asTestFileMetadata(metadata);
    }
    test(test) {
        if (!test) {
            throw new errors_1.JestMetadataError('Cannot query metadata for an undefined test');
        }
        const metadata = this[_associate].get(test.path);
        return this[_checker].asTestFileMetadata(metadata);
    }
    testCaseResult(testCaseResult) {
        if (!testCaseResult) {
            throw new errors_1.JestMetadataError('Cannot query metadata for an undefined test case result');
        }
        const metadata = this[_associate].get(testCaseResult);
        return this[_checker].asTestEntryMetadata(metadata);
    }
    testResult(testResult) {
        if (!testResult) {
            throw new errors_1.JestMetadataError('Cannot query metadata for an undefined test result');
        }
        const metadata = this[_associate].get(testResult.testFilePath);
        return this[_checker].asTestFileMetadata(metadata);
    }
    globalMetadata() {
        const metadata = this[_associate].get();
        return this[_checker].asGlobalMetadata(metadata);
    }
}
exports.QueryMetadata = QueryMetadata;
//# sourceMappingURL=QueryMetadata.js.map