import type { Emitter } from '../../types';
import { diagnostics } from '../logger';
declare const ONCE: unique symbol;
/**
 * An event emitter that emits events in the order they are received.
 * If an event is emitted while another event is being emitted, the new event
 * will be queued and emitted after the current event is finished.
 */
export declare class SerialEmitter<Event extends {
    type: string;
}> implements Emitter<Event> {
    #private;
    protected readonly _log: typeof diagnostics;
    protected readonly _listeners: Map<Event['type'] | '*', Function[]>;
    constructor(name?: string, shouldLog?: boolean);
    on<E extends Event>(type: E['type'] | '*', listener: Function & {
        [ONCE]?: true;
    }): this;
    once<E extends Event>(type: E['type'] | '*', listener: Function): this;
    off<E extends Event>(type: E['type'] | '*', listener: Function & {
        [ONCE]?: true;
    }): this;
    emit(nextEvent: Event): void;
    protected _getListeners(type: Event['type']): Function[];
}
export {};
