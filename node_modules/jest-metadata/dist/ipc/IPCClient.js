"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPCClient = void 0;
const tslib_1 = require("tslib");
const node_ipc_1 = tslib_1.__importDefault(require("node-ipc"));
const strip_ansi_1 = tslib_1.__importDefault(require("strip-ansi"));
const errors_1 = require("../errors");
const metadata_1 = require("../metadata");
const utils_1 = require("../utils");
const sendAsyncMessage_1 = require("./sendAsyncMessage");
const log = utils_1.diagnostics.child({ cat: ['ipc', 'ipc-client'], tid: 'jest-metadata-ipc' });
const __SEND = (0, utils_1.optimizeTracing)((msg) => ({ msg }));
const __OMIT = (0, utils_1.optimizeTracing)((event) => ({ event }));
const __ERROR = (0, utils_1.optimizeTracing)((error) => ({ cat: ['error'], error }));
class IPCClient {
    _ipc;
    _serverId;
    _startPromise;
    _stopPromise;
    _queue = [];
    _connection;
    _globalMetadata;
    constructor(config) {
        if (!config.serverId) {
            throw new errors_1.JestMetadataError('IPC server ID is not specified when creating IPC client.');
        }
        if (!config.clientId) {
            throw new errors_1.JestMetadataError('IPC client ID is not specified when creating IPC client.');
        }
        this._globalMetadata = config.globalMetadata;
        this._ipc = new node_ipc_1.default.IPC();
        this._serverId = config.serverId;
        Object.assign(this._ipc.config, {
            id: config.clientId,
            appspace: config.appspace,
            logger: (0, utils_1.optimizeTracing)((msg) => log.trace((0, strip_ansi_1.default)(msg))),
            stopRetrying: 0,
            maxRetries: 0,
        });
    }
    get id() {
        return this._ipc.config.id;
    }
    start() {
        if (!this._startPromise) {
            this._startPromise = log.trace.complete('start', this._doStart());
        }
        return this._startPromise;
    }
    stop() {
        if (!this._stopPromise) {
            this._stopPromise = log.trace.complete('stop', this._doStop());
        }
        return this._stopPromise;
    }
    enqueue(event) {
        if (this._stopPromise) {
            log.debug(__OMIT(event), 'enqueue (aborted)');
            return;
        }
        this._queue.push(JSON.stringify(event));
    }
    async flush(modifier) {
        if (!this._connection) {
            log.trace(__OMIT(this._queue), 'flush (no connection)');
            return;
        }
        const connection = this._connection;
        const batch = this._queue.splice(0, this._queue.length);
        if (modifier || batch.length > 0) {
            const msg = { batch };
            if (modifier === 'first') {
                msg.first = true;
            }
            if (modifier === 'last') {
                msg.last = true;
            }
            await log.trace.complete(__SEND(msg), 'send', async () => {
                const data = await (0, sendAsyncMessage_1.sendAsyncMessage)(connection, 'clientMessageBatch', msg);
                // Direct update to avoid emitting events.
                Object.assign(this._globalMetadata[metadata_1.internal.data], data);
            });
        }
        else {
            log.trace('empty-queue');
        }
    }
    async _doStart() {
        await this._stopPromise;
        this._stopPromise = undefined;
        const serverId = this._serverId;
        const connection = await new Promise((resolve) => {
            const onConnect = (client) => {
                const connection = client.of[serverId];
                const onError = (err) => {
                    unsubscribe();
                    log.error(__ERROR(err), 'Failed to connect to IPC server.');
                    resolve(void 0);
                };
                const onDisconnect = () => {
                    unsubscribe();
                    log.error(__ERROR(void 0), 'IPC server has unexpectedly disconnected.');
                    resolve(void 0);
                };
                const onConnect = () => {
                    unsubscribe();
                    resolve(client.of[serverId]);
                };
                const unsubscribe = () => {
                    connection.off('error', onError);
                    connection.off('disconnect', onDisconnect);
                    connection.off('connect', onConnect);
                };
                connection.on('error', onError).on('disconnect', onDisconnect).on('connect', onConnect);
            };
            // @ts-expect-error TS2769: No overload matches this call.
            this._ipc.connectTo(serverId, onConnect);
        });
        if (connection) {
            this._connection = connection;
            this._connection.on('beforeExit', () => this.stop());
            await this.flush('first');
        }
    }
    async _doStop() {
        await this._startPromise;
        this._startPromise = undefined;
        if (this._connection) {
            await this.flush('last');
            await new Promise((resolve, reject) => {
                this._ipc.of[this._serverId]
                    // @ts-expect-error TS2339: Property 'once' does not exist on type 'Client'.
                    .once('disconnect', resolve)
                    .once('error', reject);
                this._ipc.disconnect(this._serverId);
            });
            this._connection = undefined;
        }
    }
}
exports.IPCClient = IPCClient;
//# sourceMappingURL=IPCClient.js.map