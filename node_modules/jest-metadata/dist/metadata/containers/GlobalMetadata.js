"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMetadata = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("../../errors");
const symbols = tslib_1.__importStar(require("../symbols"));
const BaseMetadata_1 = require("./BaseMetadata");
const $byTestFilePath = Symbol('byTestFilePath');
class GlobalMetadata extends BaseMetadata_1.BaseMetadata {
    [$byTestFilePath] = new Map();
    testFiles = [];
    get currentMetadata() {
        const file = this.lastTestFile;
        if (!file) {
            return this;
        }
        // TODO: maybe file.current.value() should not return undefined?
        const current = file.current.value();
        if (current) {
            return current;
        }
        return file;
    }
    get lastTestFile() {
        return this.testFiles[this.testFiles.length - 1];
    }
    getTestFileMetadata(testFilePath) {
        if (!this.hasTestFileMetadata(testFilePath)) {
            throw new errors_1.JestMetadataError(`No file metadata found for: ${testFilePath}`);
        }
        return this[$byTestFilePath].get(testFilePath);
    }
    hasTestFileMetadata(testFilePath) {
        return this[$byTestFilePath].has(testFilePath);
    }
    registerTestFile(testFilePath) {
        const existingTestFileMetadata = this[$byTestFilePath].get(testFilePath);
        if (existingTestFileMetadata) {
            return existingTestFileMetadata;
        }
        const testFileMetadata = this[symbols.context].factory.createTestFileMetadata(testFilePath, this);
        this.testFiles.push(testFileMetadata);
        this[$byTestFilePath].set(testFilePath, testFileMetadata);
        return testFileMetadata;
    }
}
exports.GlobalMetadata = GlobalMetadata;
//# sourceMappingURL=GlobalMetadata.js.map