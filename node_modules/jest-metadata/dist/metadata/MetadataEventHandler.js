"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataEventHandler = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("../errors");
const ids_1 = require("./ids");
const internal = tslib_1.__importStar(require("./symbols"));
class MetadataEventHandler {
    config;
    _metadata;
    _metadataRegistry;
    _handlers = {
        setup: (_event) => {
            /* no-op */
        },
        add_test_file: (event) => {
            this._metadata.registerTestFile(event.testFilePath);
        },
        start_describe_definition: (event) => {
            const file = this._metadata.getTestFileMetadata(event.testFilePath);
            const describeId = new ids_1.AggregatedIdentifier(event.testFilePath, event.describeId);
            const currentDescribeBlock = file.current.describeBlock;
            (currentDescribeBlock ?? file)[internal.addDescribeBlock](describeId);
        },
        add_hook: (event) => {
            const file = this._metadata.getTestFileMetadata(event.testFilePath);
            const hookId = new ids_1.AggregatedIdentifier(event.testFilePath, event.hookId);
            const currentDescribeBlock = file.current.describeBlock;
            if (!currentDescribeBlock) {
                throw new errors_1.JestMetadataError('No current describe block');
            }
            currentDescribeBlock[internal.addHookDefinition](hookId, event.hookType);
        },
        add_test: (event) => {
            const file = this._metadata.getTestFileMetadata(event.testFilePath);
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const currentDescribeBlock = file.current.describeBlock;
            if (!currentDescribeBlock) {
                throw new errors_1.JestMetadataError('No current describe block');
            }
            currentDescribeBlock[internal.addTestEntry](testId);
        },
        finish_describe_definition: (event) => {
            const describeId = new ids_1.AggregatedIdentifier(event.testFilePath, event.describeId);
            this._metadataRegistry.get(describeId)[internal.finish]();
            // TODO: [internal.as](DescribeBlockMetadata)
        },
        run_start: (event) => {
            const file = this._metadata.getTestFileMetadata(event.testFilePath);
            file[internal.start]();
        },
        run_finish: (event) => {
            const file = this._metadata.getTestFileMetadata(event.testFilePath);
            file[internal.finish]();
        },
        run_describe_start: (event) => {
            const describeId = new ids_1.AggregatedIdentifier(event.testFilePath, event.describeId);
            const describe = this._metadataRegistry.get(describeId);
            // TODO: [internal.as](DescribeBlockMetadata);
            describe[internal.start]();
        },
        hook_start: (event) => {
            const hookId = new ids_1.AggregatedIdentifier(event.testFilePath, event.hookId);
            const hookDef = this._metadataRegistry.get(hookId);
            // TODO: [internal.as](HookDefinitionMetadata);
            hookDef[internal.start]();
        },
        hook_success: (event) => {
            const hookId = new ids_1.AggregatedIdentifier(event.testFilePath, event.hookId);
            const hookDef = this._metadataRegistry.get(hookId);
            // TODO: [internal.as](HookDefinitionMetadata);
            hookDef[internal.finish]();
        },
        hook_failure: (event) => {
            const hookId = new ids_1.AggregatedIdentifier(event.testFilePath, event.hookId);
            const hookDef = this._metadataRegistry.get(hookId);
            // TODO: [internal.as](HookDefinitionMetadata);
            hookDef[internal.finish]();
        },
        run_describe_finish: (event) => {
            const describeId = new ids_1.AggregatedIdentifier(event.testFilePath, event.describeId);
            const describe = this._metadataRegistry.get(describeId);
            // TODO: [internal.as](DescribeBlockMetadata);
            describe[internal.finish]();
        },
        test_start: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            test[internal.start]();
        },
        test_started: (_event) => {
            // no-op at the moment
        },
        test_retry: (_event) => {
            // Nothing to do, because Jest Circus will emit a `test_start` event anyway right after this
        },
        test_fn_start: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            const lastInvocation = test.lastInvocation;
            if (!lastInvocation) {
                throw new errors_1.JestMetadataError('Cannot start test function without an invocation');
            }
            lastInvocation[internal.start]();
        },
        test_fn_failure: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            const lastInvocation = test.lastInvocation;
            if (!lastInvocation) {
                throw new errors_1.JestMetadataError('Cannot finish test function without an invocation');
            }
            lastInvocation[internal.finish]();
        },
        test_fn_success: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            const lastInvocation = test.lastInvocation;
            if (!lastInvocation) {
                throw new errors_1.JestMetadataError('Cannot finish test function without an invocation');
            }
            lastInvocation[internal.finish]();
        },
        test_skip: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            test[internal.finish](true);
        },
        test_todo: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            test[internal.finish]();
        },
        test_done: (event) => {
            const testId = new ids_1.AggregatedIdentifier(event.testFilePath, event.testId);
            const test = this._metadataRegistry.get(testId);
            // TODO: [internal.as](TestEntryMetadata);
            test[internal.finish]();
        },
        write_metadata: (event) => {
            const targetId = new ids_1.AggregatedIdentifier(event.testFilePath, event.targetId);
            const metadata = this._metadataRegistry.get(targetId);
            metadata[event.operation](event.path, event.value);
        },
    };
    constructor(config) {
        this.config = config;
        this._metadata = config.globalMetadata;
        this._metadataRegistry = config.metadataRegistry;
    }
    handle = (event) => {
        const handler = this._handlers[event.type];
        handler(event);
    };
    backToDescribe = (testFilePath) => {
        const file = this._metadata.getTestFileMetadata(testFilePath);
        const currentDescribeBlock = file.current.describeBlock;
        if (!currentDescribeBlock) {
            throw new errors_1.JestMetadataError('No current describe block');
        }
        file[internal.currentMetadata] = currentDescribeBlock;
    };
}
exports.MetadataEventHandler = MetadataEventHandler;
//# sourceMappingURL=MetadataEventHandler.js.map