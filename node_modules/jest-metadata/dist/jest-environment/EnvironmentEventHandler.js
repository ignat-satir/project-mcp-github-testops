"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvironmentEventHandler = void 0;
const CircusInstanceCache_1 = require("./CircusInstanceCache");
class EnvironmentEventHandler {
    _instanceCache = new CircusInstanceCache_1.CircusInstanceCache();
    _testFilePath = '';
    _emitter;
    _circusEventHandlers = {
        setup: (_event, state) => {
            // Auxiliary event for ensuring that the test environment is Jest Circus, not Jest Jasmine.
            this._emitter.emit({
                type: 'setup',
                testFilePath: this._testFilePath,
            });
            // The root describe block is not emitted by Circus, so we emit it here.
            this._emitter.emit({
                type: 'start_describe_definition',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(state.rootDescribeBlock),
            });
        },
        include_test_location_in_result: () => {
            /* noop */
        },
        start_describe_definition: (_event, state) => {
            // Safeguard in case Circus ever starts emitting describe blocks.
            if (state.currentDescribeBlock === state.rootDescribeBlock) {
                return;
            }
            this._emitter.emit({
                type: 'start_describe_definition',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(state.currentDescribeBlock),
            });
        },
        add_hook: (event) => {
            this._emitter.emit({
                type: 'add_hook',
                testFilePath: this._testFilePath,
                hookId: this._instanceCache.getHookId(event.asyncError),
                hookType: event.hookType,
            });
        },
        add_test: (event) => {
            this._emitter.emit({
                type: 'add_test',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.asyncError),
            });
        },
        finish_describe_definition: (_event, state) => {
            const block = state.currentDescribeBlock;
            const lastChild = block.children[block.children.length - 1];
            this._emitter.emit({
                type: 'finish_describe_definition',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(lastChild),
            });
        },
        hook_start: (event) => {
            this._emitter.emit({
                type: 'hook_start',
                testFilePath: this._testFilePath,
                hookId: this._instanceCache.getHookId(event.hook.asyncError),
            });
        },
        hook_success: (event) => {
            this._emitter.emit({
                type: 'hook_success',
                testFilePath: this._testFilePath,
                hookId: this._instanceCache.getHookId(event.hook.asyncError),
            });
        },
        hook_failure: (event) => {
            this._emitter.emit({
                type: 'hook_failure',
                testFilePath: this._testFilePath,
                hookId: this._instanceCache.getHookId(event.hook.asyncError),
            });
        },
        test_fn_start: (event) => {
            this._emitter.emit({
                type: 'test_fn_start',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_fn_success: (event) => {
            this._emitter.emit({
                type: 'test_fn_success',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_fn_failure: (event) => {
            this._emitter.emit({
                type: 'test_fn_failure',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_retry: (event) => {
            this._emitter.emit({
                type: 'test_retry',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_start: (event) => {
            this._emitter.emit({
                type: 'test_start',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_started: (event) => {
            this._emitter.emit({
                type: 'test_started',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_skip: (event) => {
            this._emitter.emit({
                type: 'test_skip',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_todo: (event) => {
            this._emitter.emit({
                type: 'test_todo',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        test_done: (event) => {
            this._emitter.emit({
                type: 'test_done',
                testFilePath: this._testFilePath,
                testId: this._instanceCache.getTestId(event.test.asyncError),
            });
        },
        run_describe_start: (event) => {
            this._emitter.emit({
                type: 'run_describe_start',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(event.describeBlock),
            });
        },
        run_describe_finish: (event) => {
            this._emitter.emit({
                type: 'run_describe_finish',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(event.describeBlock),
            });
        },
        run_start: (_event, state) => {
            this._emitter.emit({
                type: 'finish_describe_definition',
                testFilePath: this._testFilePath,
                describeId: this._instanceCache.getDescribeId(state.rootDescribeBlock),
            });
            this._emitter.emit({
                type: 'run_start',
                testFilePath: this._testFilePath,
            });
        },
        run_finish: () => {
            this._emitter.emit({
                type: 'run_finish',
                testFilePath: this._testFilePath,
            });
        },
        teardown: () => {
            /* no-op */
        },
        error: () => {
            /* no-op */
        },
        error_handled: () => {
            /* no-op - this is a new Jest 30 event, keeping as no-op for now */
        },
    };
    constructor(config) {
        this._emitter = config.emitter;
    }
    get testFilePath() {
        return this._testFilePath;
    }
    /**
     * Since this class is instantiated only once per the whole test session
     * in the global realm (parent or child), we need to reset its instance cache
     * and update the test file path when a new test file is started.
     * @param testFilePath
     */
    handleEnvironmentCreated(testFilePath) {
        this._instanceCache = new CircusInstanceCache_1.CircusInstanceCache();
        this._testFilePath = testFilePath;
    }
    handleTestEvent = (event, state) => {
        return this._circusEventHandlers[event.name]?.(event, state);
    };
}
exports.EnvironmentEventHandler = EnvironmentEventHandler;
//# sourceMappingURL=EnvironmentEventHandler.js.map