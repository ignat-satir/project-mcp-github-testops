"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStatusDetails = getStatusDetails;
const autoIndent_1 = require("./autoIndent");
const vendor_1 = require("./vendor");
const HAS_EMPTY_FIRST_LINE = /^\s*\n/;
function getStatusDetails(maybeError) {
    if (!maybeError) {
        return;
    }
    const trace = getTrace(maybeError);
    const stackIndex = trace.indexOf('\n    at ');
    return stackIndex === -1
        ? {
            message: trace,
        }
        : {
            message: trace.slice(0, stackIndex),
            trace: (0, autoIndent_1.autoIndent)(trace).slice(stackIndex + 1),
        };
}
function getTrace(maybeError) {
    if (typeof maybeError === 'string') {
        return maybeError;
    }
    const error = maybeError;
    if ((0, vendor_1.isError)(maybeError)) {
        return restoreStack(error);
    }
    return asString(error.stack) || asString(error.message) || JSON.stringify(error);
}
function restoreStack(error) {
    const { message, name, stack } = normalizeError(error);
    if (stack && message && hasEmptyFirstLine(stack) && !HAS_EMPTY_FIRST_LINE.test(message)) {
        return `${name}: ${message}${stack.slice(stack.indexOf('\n'))}`;
    }
    return stack || String(error);
}
function hasEmptyFirstLine(stack) {
    if (!stack.includes('\n')) {
        return false;
    }
    const firstLine = stack.slice(0, stack.indexOf('\n'));
    const [, after] = firstLine.trimEnd().split(':', 2);
    return !after;
}
function normalizeError(error) {
    return {
        message: asString(error.message),
        name: asString(error.name),
        stack: asString(error.stack),
    };
}
function asString(x) {
    return x ? String(x) : '';
}
//# sourceMappingURL=getStatusDetails.js.map