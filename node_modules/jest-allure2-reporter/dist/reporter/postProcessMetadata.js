"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcessMetadata = postProcessMetadata;
const metadata_1 = require("../metadata");
const logger_1 = require("../logger");
const utils_1 = require("../utils");
const isNotProcessed = (() => {
    const set = new WeakSet();
    return (metadata) => {
        if (set.has(metadata)) {
            return false;
        }
        set.add(metadata);
        return true;
    };
})();
async function postProcessMetadata(globalContext, testInvocation) {
    const config = globalContext.reporterConfig;
    if (!config.sourceCode.enabled) {
        return;
    }
    const batch = [
        ...testInvocation.allAncestors(),
        testInvocation,
        ...testInvocation.allInvocations(),
    ].filter(isNotProcessed);
    await Promise.all(batch.map(async (metadata) => {
        const allureProxy = new metadata_1.AllureMetadataProxy(metadata);
        const context = (0, utils_1.compactObject)({
            ...allureProxy.get('sourceLocation'),
            transformedCode: allureProxy.get('transformedCode'),
        });
        if (!(0, utils_1.isEmpty)(context)) {
            for (const p of config.sourceCode.plugins) {
                try {
                    const docblock = await p.extractDocblock?.(context);
                    if (docblock) {
                        allureProxy.assign({ docblock });
                        break;
                    }
                }
                catch (error) {
                    logger_1.log.warn(error, `Plugin "${p.name}" failed to extract docblock for ${context.fileName}:${context.lineNumber}:${context.columnNumber}`);
                }
            }
        }
    }));
}
//# sourceMappingURL=postProcessMetadata.js.map