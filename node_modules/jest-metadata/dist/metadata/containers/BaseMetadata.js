"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseMetadata = void 0;
const tslib_1 = require("tslib");
/* eslint-disable unicorn/no-null */
const lodash_merge_1 = tslib_1.__importDefault(require("lodash.merge"));
const utils_1 = require("../../utils");
const symbols = tslib_1.__importStar(require("../symbols"));
const log = utils_1.diagnostics.child({ cat: 'metadata', tid: 'jest-metadata' });
const __LOG_METADATA = (0, utils_1.optimizeTracing)((metadata, id) => {
    log.trace({ id }, metadata.constructor.name);
});
class BaseMetadata {
    [symbols.id];
    [symbols.context];
    [symbols.data] = {};
    constructor(context, id) {
        __LOG_METADATA(this, id);
        this[symbols.context] = context;
        this[symbols.id] = id;
    }
    get id() {
        return this[symbols.id].toString();
    }
    get(path, fallbackValue) {
        return this.#get(path, fallbackValue);
    }
    set(path, $value) {
        const value = this.#sanitize($value);
        this.#assertPath(path, 'set');
        this.#set(path, value);
        this[symbols.context].emitter.emit({
            type: 'write_metadata',
            testFilePath: this[symbols.id].testFilePath,
            targetId: this[symbols.id].identifier,
            path,
            value,
            operation: 'set',
        });
        return this;
    }
    push(path, $values) {
        return this.#concat('push', path, this.#sanitize($values));
    }
    unshift(path, $values) {
        return this.#concat('unshift', path, this.#sanitize($values));
    }
    assign(path, $value) {
        const oldValue = this.#get(path, {});
        const source = oldValue && typeof oldValue === 'object' ? oldValue : {};
        const value = this.#sanitize($value);
        Object.assign(source, value);
        if (path != null) {
            this.#set(path, source);
        }
        this[symbols.context].emitter.emit({
            type: 'write_metadata',
            testFilePath: this[symbols.id].testFilePath,
            targetId: this[symbols.id].identifier,
            path,
            value,
            operation: 'assign',
        });
        return this;
    }
    defaults(path, $value) {
        const oldValue = this.#get(path, {});
        const value = this.#sanitize($value);
        const source = (oldValue && typeof oldValue === 'object' ? oldValue : {});
        for (const key of Object.keys(value)) {
            if (source[key] === undefined) {
                source[key] = $value[key];
            }
        }
        if (path != null) {
            this.#set(path, source);
        }
        this[symbols.context].emitter.emit({
            type: 'write_metadata',
            testFilePath: this[symbols.id].testFilePath,
            targetId: this[symbols.id].identifier,
            path,
            value,
            operation: 'defaults',
        });
        return this;
    }
    merge(path, $value) {
        const oldValue = this.#get(path, {});
        const value = this.#sanitize($value);
        const source = oldValue && typeof oldValue === 'object' ? oldValue : {};
        (0, lodash_merge_1.default)(source, value);
        if (path != null) {
            this.#set(path, source);
        }
        this[symbols.context].emitter.emit({
            type: 'write_metadata',
            testFilePath: this[symbols.id].testFilePath,
            targetId: this[symbols.id].identifier,
            path,
            value,
            operation: 'merge',
        });
        return this;
    }
    toJSON() {
        return {
            id: this.id,
            type: this.constructor.name,
            data: this[symbols.data],
        };
    }
    #get(path, fallbackValue) {
        return path == null ? this[symbols.data] : (0, utils_1.get)(this[symbols.data], path, fallbackValue);
    }
    #set(path, value) {
        (0, utils_1.set)(this[symbols.data], path, value);
    }
    #assertPath(path, operationName) {
        if (path == null) {
            throw new TypeError(`Cannot ${operationName} metadata without a path`);
        }
    }
    #concat(operation, path, values) {
        this.#assertPath(path, `${operation} to`);
        if (!Array.isArray(values)) {
            throw new TypeError(`Cannot ${operation} a non-array value to path "${path}". Received: ${values}`);
        }
        const array = (0, utils_1.get)(this[symbols.data], path, []);
        if (!Array.isArray(array)) {
            throw new TypeError(`Cannot ${operation} to path "${path}", because it is not an array, but: ${array}`);
        }
        array[operation](...values);
        this.#set(path, array);
        this[symbols.context].emitter.emit({
            type: 'write_metadata',
            testFilePath: this[symbols.id].testFilePath,
            targetId: this[symbols.id].identifier,
            path,
            value: values,
            operation,
        });
        return this;
    }
    #sanitize(value) {
        try {
            return JSON.parse(JSON.stringify(value));
        }
        catch {
            throw new TypeError(`Given value cannot be serialized to JSON: ${value}`);
        }
    }
}
exports.BaseMetadata = BaseMetadata;
//# sourceMappingURL=BaseMetadata.js.map