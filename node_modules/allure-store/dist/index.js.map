{
  "version": 3,
  "sources": ["../src/index.ts", "../src/FileAllureReader.ts", "../src/errors.ts", "../src/FileAllureWriter.ts", "../src/AllureStore.ts"],
  "sourcesContent": ["import type {AllureStoreConfig, AllureStoreDirectoryConfig} from './AllureStore';\nimport { AllureStore } from './AllureStore';\n\n/**\n * Create an AllureStore from a configuration object.\n */\nexport async function fromConfig(options: AllureStoreConfig): Promise<AllureStore> {\n  return AllureStore.fromConfig(options);\n}\n\n/**\n * Create an AllureStore from a directory configuration.\n */\nexport async function fromDirectory(resultsDirectory: string, options?: AllureStoreDirectoryConfig): Promise<AllureStore> {\n  return AllureStore.fromDirectory(resultsDirectory, options);\n}\n\nexport { type AllureReader } from './AllureReader';\nexport { type AllureWriter } from './AllureWriter';\nexport { AllureStore, type AllureStoreConfig, type AllureStoreDirectoryConfig } from './AllureStore';\nexport { FileAllureWriter, type FileSystemAllureWriterConfig } from './FileAllureWriter';\nexport { FileAllureReader, type FileAllureReaderConfig } from './FileAllureReader';\nexport * from './types';\n", "/// <reference path=\"external.d.ts\" />\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\nimport * as properties from 'properties';\n\nimport type {AllureReader} from './AllureReader';\nimport type {Category, Container, ExecutorInfo, Result} from './types';\nimport {AllureStoreError, type OnErrorHandler, resolveOnError} from './errors';\n\nexport interface FileAllureReaderConfig {\n  resultsDirectory: string;\n  onError?: OnErrorHandler;\n}\n\nexport class FileAllureReader implements AllureReader {\n  readonly #resultsDirectory: string;\n  readonly #onError: ((error: Error) => void);\n  #scanIdsPromise?: Promise<void>;\n  #containerIds?: string[];\n  #resultIds?: string[];\n\n  constructor(config: FileAllureReaderConfig) {\n    this.#resultsDirectory = config.resultsDirectory;\n    this.#onError = resolveOnError(config.onError || 'throw');\n  }\n\n  async getContainerIds(): Promise<string[]> {\n    if (!this.#scanIdsPromise) {\n      this.#scanIdsPromise = this.#scanIds();\n    }\n    await this.#scanIdsPromise;\n    return this.#containerIds || [];\n  }\n\n  async getResultIds(): Promise<string[]> {\n    if (!this.#scanIdsPromise) {\n      this.#scanIdsPromise = this.#scanIds();\n    }\n    await this.#scanIdsPromise;\n    return this.#resultIds || [];\n  }\n\n  async readResult(id: string): Promise<Result | null> {\n    const filePath = path.join(this.#resultsDirectory, `${id}-result.json`);\n    return this.#parseJSON<Result>(filePath);\n  }\n\n  async readContainer(id: string): Promise<Container | null> {\n    const filePath = path.join(this.#resultsDirectory, `${id}-container.json`);\n    return this.#parseJSON<Container>(filePath);\n  }\n\n  async readCategories(): Promise<Category[] | null> {\n    const filePath = path.join(this.#resultsDirectory, 'categories.json');\n    return this.#parseJSON<Category[]>(filePath);\n  }\n\n  async readEnvironmentInfo(): Promise<Record<string, string> | null> {\n    const filePath = path.join(this.#resultsDirectory, 'environment.properties');\n    const content = await this.#readFileIfExists(filePath);\n    if (!content) return null;\n    return properties.parse(content, { sections: false, comments: '#', separators: '=', unicode: true });\n  }\n\n  async readExecutorInfo(): Promise<ExecutorInfo | null> {\n    const filePath = path.join(this.#resultsDirectory, 'executor.json');\n    return this.#parseJSON<ExecutorInfo>(filePath);\n  }\n\n  /**\n   * Helper method to read and parse JSON files.\n   */\n  async #parseJSON<T>(filePath: string): Promise<T | null> {\n    try {\n      const content = await this.#readFileIfExists(filePath);\n      return content ? (JSON.parse(content) as T) : null;\n    } catch (error: unknown) {\n      this.#handleError(`Failed to parse JSON file: ${filePath}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Helper method to safely read a file, returning `null` if it doesn't exist.\n   */\n  async #readFileIfExists(filePath: string): Promise<string | null> {\n    try {\n      return await fs.readFile(filePath, 'utf8');\n    } catch (error: unknown) {\n      this.#handleError(`Failed to read file: ${filePath}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Helper method to list the contents of the results directory and cache the IDs.\n   */\n  async #scanIds(): Promise<void> {\n    let files: string[] = [];\n    try {\n      files = await fs.readdir(this.#resultsDirectory);\n    } catch (error: unknown) {\n      this.#handleError(`Failed to list directory: ${this.#resultsDirectory}`, error);\n      files = [];\n    }\n\n    this.#containerIds = files\n      .filter((f) => f.endsWith('-container.json'))\n      .map((f) => path.basename(f, '-container.json'));\n\n    this.#resultIds = files\n      .filter((f) => f.endsWith('-result.json'))\n      .map((f) => path.basename(f, '-result.json'));\n  }\n\n  #handleError(message: string, cause?: unknown): void {\n    this.#onError(new AllureStoreError(message, cause));\n  }\n}\n", "/** The allowed types for `onError` configuration. */\nexport type OnErrorHandler = ((error: Error) => void) | 'throw' | 'ignore';\n\n/** Resolve the given `onError` handler into a function that handles errors consistently. */\nexport function resolveOnError(onError: OnErrorHandler): (error: Error) => void {\n  if (onError === undefined || onError === 'throw') {\n    return (e: Error) => { throw e; };\n  } else if (onError === 'ignore') {\n    return () => {};\n  } else {\n    // custom error function\n    return onError;\n  }\n}\n\nexport class AllureStoreError extends Error {\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message, { cause });\n    this.name = 'AllureStoreError';\n  }\n}\n", "/// <reference path=\"external.d.ts\" />\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\nimport * as properties from 'properties';\n\nimport type {AllureWriter} from './AllureWriter';\nimport type {CategoryInput, Container, ExecutorInfo, Result} from './types';\nimport type { OnErrorHandler} from './errors';\nimport {AllureStoreError, resolveOnError} from './errors';\n\nexport interface FileSystemAllureWriterConfig {\n  overwrite?: boolean;\n  resultsDirectory: string;\n  onError?: OnErrorHandler;\n}\n\nexport class FileAllureWriter implements AllureWriter {\n  readonly #config: FileSystemAllureWriterConfig;\n  readonly #onError: ((error: Error) => void);\n\n  constructor(config: FileSystemAllureWriterConfig) {\n    this.#config = config;\n    this.#onError = resolveOnError(config.onError || 'throw');\n  }\n\n  async init(): Promise<void> {\n    const { resultsDirectory, overwrite } = this.#config;\n    try {\n      const directoryExists = await fs.access(resultsDirectory).then(\n        () => true,\n        // throw if not ENOENT\n        (error) => {\n          if (error?.code !== 'ENOENT') throw error;\n          return false;\n        },\n      );\n      if (overwrite && directoryExists) {\n        await fs.rm(resultsDirectory, { recursive: true });\n      }\n      await fs.mkdir(resultsDirectory, { recursive: true });\n    } catch (error: unknown) {\n      this.#handleError(`Failed to initialize results directory: ${resultsDirectory}`, error);\n    }\n  }\n\n  async writeCategories(categories: CategoryInput[]): Promise<void> {\n    const filePath = this.#buildPath('categories.json');\n    try {\n      await writeJson(filePath, categories, regexpAwareStringifier);\n    } catch (error: unknown) {\n      this.#handleError(`Failed to write categories: ${filePath}`, error);\n    }\n  }\n\n  async writeContainer(container: Container): Promise<void> {\n    const filePath = this.#buildPath(`${container.uuid}-container.json`);\n    try {\n      await writeJson(filePath, container);\n    } catch (error: unknown) {\n      this.#handleError(`Failed to write container: ${filePath}`, error);\n    }\n  }\n\n  async writeEnvironmentInfo(info: Record<string, unknown>): Promise<void> {\n    const filePath = this.#buildPath('environment.properties');\n    try {\n      const text = properties.stringify(info, { unicode: true });\n      await fs.writeFile(filePath, text + '\\n');\n    } catch (error: unknown) {\n      this.#handleError(`Failed to write environment info: ${filePath}`, error);\n    }\n  }\n\n  async writeExecutorInfo(info: ExecutorInfo): Promise<void> {\n    const filePath = this.#buildPath('executor.json');\n    try {\n      await writeJson(filePath, info);\n    } catch (error: unknown) {\n      this.#handleError(`Failed to write executor info: ${filePath}`, error);\n    }\n  }\n\n  async writeResult(result: Result): Promise<void> {\n    const filePath = this.#buildPath(`${result.uuid}-result.json`);\n    try {\n      await writeJson(filePath, result);\n    } catch (error: unknown) {\n      this.#handleError(`Failed to write result: ${filePath}`, error);\n    }\n  }\n\n  #buildPath(name: string): string {\n    return path.join(this.#config.resultsDirectory, name);\n  }\n\n  #handleError(message: string, cause?: unknown): void {\n    this.#onError(new AllureStoreError(message, cause));\n  }\n}\n\nasync function writeJson(\n  filePath: string,\n  data: unknown,\n  stringifier?: (key: string, value: unknown) => unknown,\n) {\n  const json = JSON.stringify(data, stringifier);\n  await fs.writeFile(filePath, json + '\\n');\n}\n\nfunction regexpAwareStringifier(_key: string, value: unknown) {\n  return value instanceof RegExp ? value.source : value;\n}\n\n", "import type { AllureReader } from './AllureReader';\nimport type { AllureWriter } from './AllureWriter';\nimport { FileAllureReader } from './FileAllureReader';\nimport { FileAllureWriter } from './FileAllureWriter';\nimport type { Category, CategoryInput, Container, ExecutorInfo, Result } from './types';\n\nexport interface AllureStoreConfig {\n  reader: AllureReader;\n  writer: AllureWriter;\n}\n\nexport interface AllureStoreDirectoryConfig {\n  overwrite?: boolean;\n  onError?: ((error: Error) => void) | 'throw' | 'ignore';\n}\n\nexport class AllureStore {\n  readonly #reader: AllureReader;\n  readonly #writer: AllureWriter;\n\n  constructor(config: AllureStoreConfig) {\n    this.#reader = config.reader;\n    this.#writer = config.writer;\n  }\n\n  static async fromConfig(config: AllureStoreConfig): Promise<AllureStore> {\n    await Promise.all([config.reader.init?.(), config.writer.init?.()]);\n    return new AllureStore(config);\n  }\n\n  static async fromDirectory(resultsDirectory: string, config: AllureStoreDirectoryConfig = {}): Promise<AllureStore> {\n    const reader: AllureReader = new FileAllureReader({ resultsDirectory, onError: config.onError });\n    const writer: AllureWriter = new FileAllureWriter({ resultsDirectory, onError: config.onError, overwrite: config.overwrite });\n    return AllureStore.fromConfig({ reader, writer });\n  }\n\n  //#region Reading methods\n  async getAllResults(): Promise<Result[]> {\n    const [containerIds, resultIds] = await Promise.all([\n      this.#reader.getContainerIds(),\n      this.#reader.getResultIds(),\n    ]);\n    const containerMap = await this.#buildContainerMap(containerIds);\n\n    const rawResults = await Promise.all(resultIds.map((id) => this.#reader.readResult(id)));\n    const validResults = rawResults.filter((r): r is Result => r != null);\n\n    return validResults.map((result) => this.#mergeContainers(result, containerMap));\n  }\n\n  async getLatestResults(): Promise<Result[]> {\n    const all = await this.getAllResults();\n    const map = new Map<string, Result>();\n    for (const result of all) {\n      const existing = map.get(result.historyId);\n      if (!existing || result.stop > existing.stop) {\n        map.set(result.historyId, result);\n      }\n    }\n    return [...map.values()];\n  }\n\n  async getCategories(): Promise<Category[] | null> {\n    return this.#reader.readCategories();\n  }\n\n  async getEnvironment(): Promise<Record<string, string> | null> {\n    return this.#reader.readEnvironmentInfo();\n  }\n\n  async getExecutor(): Promise<ExecutorInfo | null> {\n    return this.#reader.readExecutorInfo();\n  }\n\n  async getContainer(id: string): Promise<Container | null> {\n    return this.#reader.readContainer(id);\n  }\n\n  async getResult(id: string): Promise<Result | null> {\n    return this.#reader.readResult(id);\n  }\n  //#endregion\n\n  //#region Writing methods\n  async writeCategories(categories: CategoryInput[]): Promise<void> {\n    return this.#writer.writeCategories(categories);\n  }\n\n  async writeEnvironmentInfo(info: Record<string, string>): Promise<void> {\n    return this.#writer.writeEnvironmentInfo(info);\n  }\n\n  async writeExecutorInfo(info: ExecutorInfo): Promise<void> {\n    return this.#writer.writeExecutorInfo(info);\n  }\n\n  async writeResult(result: Result): Promise<void> {\n    return this.#writer.writeResult(result);\n  }\n\n  async writeContainer(container: Container): Promise<void> {\n    return this.#writer.writeContainer(container);\n  }\n  //#endregion\n\n  //#region Private helper methods\n  async #buildContainerMap(containerIds: string[]): Promise<Map<string, Container>> {\n    const containerMap = new Map<string, Container>();\n    // Read and store all containers\n    await Promise.all(\n      containerIds.map(async (cid) => {\n        const container = await this.#reader.readContainer(cid);\n        if (container) {\n          containerMap.set(container.uuid, container);\n        }\n      }),\n    );\n    return containerMap;\n  }\n\n  #mergeContainers(result: Result, containerMap: Map<string, Container>): Result {\n    // The aggregation logic similar to what we had before\n    const ancestors = this.#findAncestorContainers(result.uuid, containerMap);\n    const merged = { ...result, steps: this.#mergeSteps(result, ancestors) };\n    return merged;\n  }\n\n  #findAncestorContainers(\n    startId: string,\n    containerMap: Map<string, Container>,\n  ): Container[] {\n    // logic similar to previously done in aggregator class\n    const parentFor = new Map<string, string>();\n    for (const container of containerMap.values()) {\n      for (const child of container.children) {\n        parentFor.set(child, container.uuid);\n      }\n    }\n\n    const ancestors: Container[] = [];\n    let currentId: string | undefined = startId;\n    while (currentId) {\n      const parentId = parentFor.get(currentId);\n      if (!parentId) break;\n      const parentContainer = containerMap.get(parentId);\n      if (!parentContainer) break;\n      ancestors.push(parentContainer);\n      currentId = parentId;\n    }\n    return ancestors.reverse();\n  }\n\n  #mergeSteps(result: Result, ancestors: Container[]) {\n    const beforeSteps = ancestors.flatMap((a) => a.befores ?? []);\n    const afterSteps = [...ancestors].reverse().flatMap((a) => a.afters ?? []);\n    return [...beforeSteps, ...(result.steps ?? []), ...afterSteps];\n  }\n  //#endregion\n}\n"],
  "mappings": "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",
  "names": ["path", "fs", "import_promises", "import_node_path", "properties", "fs", "path"]
}
