"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const StackTrace = tslib_1.__importStar(require("stacktrace-js"));
const api = tslib_1.__importStar(require("../api"));
const realms_1 = tslib_1.__importDefault(require("../realms"));
const utils_1 = require("../utils");
const listener = (context) => {
    context.testEvents
        .once('test_environment_setup', injectGlobals)
        .once('test_environment_setup', setWorkerId)
        .once('test_environment_setup', reportSetupFiles(context.config))
        .on('add_hook', addHookType)
        .on('add_hook', addSourceLocation)
        .on('add_hook', addSourceCode)
        .on('add_test', addSourceLocation)
        .on('add_test', addSourceCode)
        .on('run_start', flush)
        .on('hook_start', executableStart)
        .on('hook_failure', executableFailure)
        .on('hook_failure', flush)
        .on('hook_success', executableSuccess)
        .on('hook_success', flush)
        .on('test_start', testStart)
        .on('test_todo', testSkip)
        .on('test_skip', testSkip)
        .on('test_done', testDone)
        .on('test_fn_start', executableStart)
        .on('test_fn_success', executableSuccess)
        .on('test_fn_success', flush)
        .on('test_fn_failure', executableFailure)
        .on('test_fn_failure', flush)
        .on('teardown', flush);
};
async function flush() {
    await realms_1.default.runtime.flush();
}
function addSourceLocation({ event, }) {
    const metadata = realms_1.default.runtimeContext.getCurrentMetadata();
    const task = StackTrace.fromError(event.asyncError).then((stackFrames) => {
        const first = stackFrames.find((s) => !(0, utils_1.isLibraryPath)(s.fileName));
        if (!first) {
            return;
        }
        const sourceLocation = {
            fileName: first.fileName,
            lineNumber: first.lineNumber,
            columnNumber: first.columnNumber,
        };
        metadata.set('sourceLocation', sourceLocation);
    });
    realms_1.default.runtimeContext.enqueueTask(task);
}
function injectGlobals({ env }) {
    env.global.__ALLURE__ = realms_1.default;
    const { injectGlobals } = realms_1.default.runtimeContext.getReporterConfig();
    if (injectGlobals) {
        Object.assign(env.global, api);
    }
}
function setWorkerId() {
    if (process.env.JEST_WORKER_ID) {
        realms_1.default.runtimeContext.getFileMetadata().push('labels', [
            {
                name: 'thread',
                value: process.env.JEST_WORKER_ID.padStart(2, '0'),
            },
        ]);
    }
    else {
        // TODO: log a warning
    }
}
function reportSetupFiles(config) {
    return () => {
        const { setupFilesAfterEnv = [], setupFiles = [] } = config.projectConfig ?? {};
        const globalMetadata = realms_1.default.runtimeContext.getGlobalMetadata();
        const loadedFiles = globalMetadata.get('loadedFiles', []);
        const files = lodash_1.default.difference([...setupFiles, ...setupFilesAfterEnv], loadedFiles);
        globalMetadata.push('loadedFiles', files);
    };
}
function addHookType({ event }) {
    const metadata = realms_1.default.runtimeContext.getCurrentMetadata();
    metadata.set('hookType', event.hookType);
}
function addSourceCode({ event }) {
    let code = '';
    if (event.name === 'add_hook') {
        const { hookType, fn } = event;
        const functionCode = String(fn);
        if (functionCode.includes("during setup, this cannot be null (and it's fine to explode if it is)")) {
            code = '';
            realms_1.default.runtimeContext
                .getCurrentMetadata()
                .set('displayName', 'Reset mocks, modules and timers (Jest)');
        }
        else {
            code = `${hookType}(${(0, utils_1.autoIndent)(functionCode)});`;
        }
    }
    if (event.name === 'add_test') {
        const { testName, fn } = event;
        code = `test(${JSON.stringify(testName)}, ${(0, utils_1.autoIndent)(String(fn))});`;
    }
    if (code) {
        realms_1.default.runtimeContext.getCurrentMetadata().set('transformedCode', (0, utils_1.autoIndent)(code));
    }
}
// eslint-disable-next-line no-empty-pattern
function executableStart(_event) {
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        stage: 'running',
        start: Date.now(),
    });
}
function executableFailure({ event: { error }, }) {
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        stage: 'interrupted',
        status: (0, utils_1.isJestAssertionError)(error) ? 'failed' : 'broken',
        statusDetails: (0, utils_1.getStatusDetails)(error),
        stop: Date.now(),
    });
}
function executableSuccess(_event) {
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        stage: 'finished',
        stop: Date.now(),
    });
}
function testStart(_event) {
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        start: Date.now(),
    });
}
function testSkip(_event) {
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        stop: Date.now(),
    });
}
function testDone({ event }) {
    const current = realms_1.default.runtimeContext.getCurrentMetadata();
    if (event.test.errors.length > 0) {
        const hasFailedAssertions = event.test.errors.some((errors) => {
            return Array.isArray(errors)
                ? errors.some(utils_1.isJestAssertionError)
                : (0, utils_1.isJestAssertionError)(errors);
        });
        current.assign({
            status: hasFailedAssertions ? 'failed' : 'broken',
        });
    }
    realms_1.default.runtimeContext.getCurrentMetadata().assign({
        stop: Date.now(),
    });
}
exports.default = listener;
//# sourceMappingURL=listener.js.map