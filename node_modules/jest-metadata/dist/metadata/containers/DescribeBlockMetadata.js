"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DescribeBlockMetadata = void 0;
const tslib_1 = require("tslib");
const symbols = tslib_1.__importStar(require("../symbols"));
const BaseMetadata_1 = require("./BaseMetadata");
class DescribeBlockMetadata extends BaseMetadata_1.BaseMetadata {
    file;
    parent;
    children = [];
    executions = [];
    #pendingBeforeAll = [];
    #pendingAfterAll = [];
    #firstTestInvocation;
    #lastAttachable;
    constructor(context, parent, id) {
        super(context, id);
        if (context.checker.isTestFileMetadata(parent)) {
            this.parent = undefined;
            this.file = parent;
        }
        else {
            this.parent = parent;
            this.file = parent.file;
        }
    }
    [symbols.addDescribeBlock](id) {
        const describeBlock = this[symbols.context].factory.createDescribeBlockMetadata(this, id);
        this.children.push(describeBlock);
        this.file[symbols.currentMetadata] = describeBlock;
        return describeBlock;
    }
    [symbols.addTestEntry](id) {
        const testEntry = this[symbols.context].factory.createTestEntryMetadata(this, id);
        this.children.push(testEntry);
        this.file[symbols.currentMetadata] = testEntry;
        this.file[symbols.lastTestEntry] = testEntry;
        return testEntry;
    }
    [symbols.addHookDefinition](id, hookType) {
        const hookDefinition = this[symbols.context].factory.createHookDefinitionMetadata(this, id, hookType);
        this.children.push(hookDefinition);
        this.file[symbols.currentMetadata] = hookDefinition;
        return hookDefinition;
    }
    [symbols.pushExecution](metadata) {
        this.executions.push(metadata);
        const { checker } = this[symbols.context];
        if (checker.isHookInvocationMetadata(metadata)) {
            if (metadata.definition.hookType === 'afterAll') {
                this.#pendingAfterAll.push(metadata);
            }
            else {
                this.#pendingBeforeAll.push(metadata);
            }
        }
        else {
            if (!this.#firstTestInvocation && checker.isTestInvocationMetadata(metadata)) {
                this.#firstTestInvocation = metadata;
            }
            this.#lastAttachable = metadata;
        }
    }
    [symbols.pushBeforeAll](testInvocation) {
        if (this.parent) {
            this.parent[symbols.pushBeforeAll](testInvocation);
        }
        if (this.#pendingBeforeAll.length > 0) {
            testInvocation[symbols.pushBeforeAll](this.#pendingBeforeAll.splice(0));
        }
    }
    [symbols.pushAfterAll](invocations) {
        this.#lastAttachable?.[symbols.pushAfterAll](invocations);
    }
    [symbols.start]() {
        this.file[symbols.currentMetadata] = this;
        this.parent?.[symbols.pushExecution](this);
    }
    [symbols.finish]() {
        this.file[symbols.currentMetadata] = this.parent ?? this.file;
        if (this.#pendingBeforeAll.length > 0 && this.#firstTestInvocation) {
            // NOTE: special case when it.todo() is the only test in a describe block
            // For some unknown reason, the hooks surrounding it are executed, so
            // it's better not to lose the information about them.
            this[symbols.pushBeforeAll](this.#firstTestInvocation);
        }
        if (this.#pendingAfterAll.length > 0) {
            this[symbols.pushAfterAll](this.#pendingAfterAll.splice(0));
        }
    }
    *ancestors() {
        let it = this;
        while ((it = it.parent)) {
            yield it;
        }
    }
    *allAncestors() {
        yield* this.ancestors();
        yield this.file;
        yield this.file.globalMetadata;
    }
    *describeBlocks() {
        const checker = this[symbols.context].checker;
        for (const child of this.children) {
            if (checker.isDescribeBlockMetadata(child)) {
                yield child;
            }
        }
    }
    *testEntries() {
        const checker = this[symbols.context].checker;
        for (const child of this.children) {
            if (checker.isTestEntryMetadata(child)) {
                yield child;
            }
        }
    }
    *hookDefinitions() {
        const checker = this[symbols.context].checker;
        for (const child of this.children) {
            if (checker.isHookDefinitionMetadata(child)) {
                yield child;
            }
        }
    }
    *allDescribeBlocks() {
        const checker = this[symbols.context].checker;
        for (const child of this.children) {
            if (checker.isDescribeBlockMetadata(child)) {
                yield child;
                yield* child.allDescribeBlocks();
            }
        }
    }
    *allTestEntries() {
        const checker = this[symbols.context].checker;
        for (const child of this.children) {
            if (checker.isTestEntryMetadata(child)) {
                yield child;
            }
            else if (checker.isDescribeBlockMetadata(child)) {
                yield* child.allTestEntries();
            }
        }
    }
    *allInvocations() {
        const checker = this[symbols.context].checker;
        for (const execution of this.executions) {
            if (checker.isHookInvocationMetadata(execution)) {
                yield execution;
            }
            else if (checker.isDescribeBlockMetadata(execution)) {
                yield* execution.allInvocations();
            }
            else if (checker.isTestInvocationMetadata(execution)) {
                yield* execution.invocations();
            }
        }
    }
    *allTestInvocations() {
        const checker = this[symbols.context].checker;
        for (const execution of this.executions) {
            if (checker.isDescribeBlockMetadata(execution)) {
                yield* execution.allTestInvocations();
            }
            else if (checker.isTestInvocationMetadata(execution)) {
                yield execution;
            }
        }
    }
}
exports.DescribeBlockMetadata = DescribeBlockMetadata;
//# sourceMappingURL=DescribeBlockMetadata.js.map