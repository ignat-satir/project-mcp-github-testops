"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AllureStore: () => AllureStore,
  FileAllureReader: () => FileAllureReader,
  FileAllureWriter: () => FileAllureWriter,
  fromConfig: () => fromConfig,
  fromDirectory: () => fromDirectory
});
module.exports = __toCommonJS(index_exports);

// src/FileAllureReader.ts
var import_promises = __toESM(require("node:fs/promises"));
var import_node_path = __toESM(require("node:path"));
var properties = __toESM(require("properties"));

// src/errors.ts
function resolveOnError(onError) {
  if (onError === void 0 || onError === "throw") {
    return (e) => {
      throw e;
    };
  } else if (onError === "ignore") {
    return () => {
    };
  } else {
    return onError;
  }
}
var AllureStoreError = class extends Error {
  constructor(message, cause) {
    super(message, { cause });
    this.cause = cause;
    this.name = "AllureStoreError";
  }
};

// src/FileAllureReader.ts
var FileAllureReader = class {
  #resultsDirectory;
  #onError;
  #scanIdsPromise;
  #containerIds;
  #resultIds;
  constructor(config) {
    this.#resultsDirectory = config.resultsDirectory;
    this.#onError = resolveOnError(config.onError || "throw");
  }
  async getContainerIds() {
    if (!this.#scanIdsPromise) {
      this.#scanIdsPromise = this.#scanIds();
    }
    await this.#scanIdsPromise;
    return this.#containerIds || [];
  }
  async getResultIds() {
    if (!this.#scanIdsPromise) {
      this.#scanIdsPromise = this.#scanIds();
    }
    await this.#scanIdsPromise;
    return this.#resultIds || [];
  }
  async readResult(id) {
    const filePath = import_node_path.default.join(this.#resultsDirectory, `${id}-result.json`);
    return this.#parseJSON(filePath);
  }
  async readContainer(id) {
    const filePath = import_node_path.default.join(this.#resultsDirectory, `${id}-container.json`);
    return this.#parseJSON(filePath);
  }
  async readCategories() {
    const filePath = import_node_path.default.join(this.#resultsDirectory, "categories.json");
    return this.#parseJSON(filePath);
  }
  async readEnvironmentInfo() {
    const filePath = import_node_path.default.join(this.#resultsDirectory, "environment.properties");
    const content = await this.#readFileIfExists(filePath);
    if (!content) return null;
    return properties.parse(content, { sections: false, comments: "#", separators: "=", unicode: true });
  }
  async readExecutorInfo() {
    const filePath = import_node_path.default.join(this.#resultsDirectory, "executor.json");
    return this.#parseJSON(filePath);
  }
  /**
   * Helper method to read and parse JSON files.
   */
  async #parseJSON(filePath) {
    try {
      const content = await this.#readFileIfExists(filePath);
      return content ? JSON.parse(content) : null;
    } catch (error) {
      this.#handleError(`Failed to parse JSON file: ${filePath}`, error);
      return null;
    }
  }
  /**
   * Helper method to safely read a file, returning `null` if it doesn't exist.
   */
  async #readFileIfExists(filePath) {
    try {
      return await import_promises.default.readFile(filePath, "utf8");
    } catch (error) {
      this.#handleError(`Failed to read file: ${filePath}`, error);
      return null;
    }
  }
  /**
   * Helper method to list the contents of the results directory and cache the IDs.
   */
  async #scanIds() {
    let files = [];
    try {
      files = await import_promises.default.readdir(this.#resultsDirectory);
    } catch (error) {
      this.#handleError(`Failed to list directory: ${this.#resultsDirectory}`, error);
      files = [];
    }
    this.#containerIds = files.filter((f) => f.endsWith("-container.json")).map((f) => import_node_path.default.basename(f, "-container.json"));
    this.#resultIds = files.filter((f) => f.endsWith("-result.json")).map((f) => import_node_path.default.basename(f, "-result.json"));
  }
  #handleError(message, cause) {
    this.#onError(new AllureStoreError(message, cause));
  }
};

// src/FileAllureWriter.ts
var import_promises2 = __toESM(require("node:fs/promises"));
var import_node_path2 = __toESM(require("node:path"));
var properties2 = __toESM(require("properties"));
var FileAllureWriter = class {
  #config;
  #onError;
  constructor(config) {
    this.#config = config;
    this.#onError = resolveOnError(config.onError || "throw");
  }
  async init() {
    const { resultsDirectory, overwrite } = this.#config;
    try {
      const directoryExists = await import_promises2.default.access(resultsDirectory).then(
        () => true,
        // throw if not ENOENT
        (error) => {
          if ((error == null ? void 0 : error.code) !== "ENOENT") throw error;
          return false;
        }
      );
      if (overwrite && directoryExists) {
        await import_promises2.default.rm(resultsDirectory, { recursive: true });
      }
      await import_promises2.default.mkdir(resultsDirectory, { recursive: true });
    } catch (error) {
      this.#handleError(`Failed to initialize results directory: ${resultsDirectory}`, error);
    }
  }
  async writeCategories(categories) {
    const filePath = this.#buildPath("categories.json");
    try {
      await writeJson(filePath, categories, regexpAwareStringifier);
    } catch (error) {
      this.#handleError(`Failed to write categories: ${filePath}`, error);
    }
  }
  async writeContainer(container) {
    const filePath = this.#buildPath(`${container.uuid}-container.json`);
    try {
      await writeJson(filePath, container);
    } catch (error) {
      this.#handleError(`Failed to write container: ${filePath}`, error);
    }
  }
  async writeEnvironmentInfo(info) {
    const filePath = this.#buildPath("environment.properties");
    try {
      const text = properties2.stringify(info, { unicode: true });
      await import_promises2.default.writeFile(filePath, text + "\n");
    } catch (error) {
      this.#handleError(`Failed to write environment info: ${filePath}`, error);
    }
  }
  async writeExecutorInfo(info) {
    const filePath = this.#buildPath("executor.json");
    try {
      await writeJson(filePath, info);
    } catch (error) {
      this.#handleError(`Failed to write executor info: ${filePath}`, error);
    }
  }
  async writeResult(result) {
    const filePath = this.#buildPath(`${result.uuid}-result.json`);
    try {
      await writeJson(filePath, result);
    } catch (error) {
      this.#handleError(`Failed to write result: ${filePath}`, error);
    }
  }
  #buildPath(name) {
    return import_node_path2.default.join(this.#config.resultsDirectory, name);
  }
  #handleError(message, cause) {
    this.#onError(new AllureStoreError(message, cause));
  }
};
async function writeJson(filePath, data, stringifier) {
  const json = JSON.stringify(data, stringifier);
  await import_promises2.default.writeFile(filePath, json + "\n");
}
function regexpAwareStringifier(_key, value) {
  return value instanceof RegExp ? value.source : value;
}

// src/AllureStore.ts
var AllureStore = class _AllureStore {
  #reader;
  #writer;
  constructor(config) {
    this.#reader = config.reader;
    this.#writer = config.writer;
  }
  static async fromConfig(config) {
    var _a, _b, _c, _d;
    await Promise.all([(_b = (_a = config.reader).init) == null ? void 0 : _b.call(_a), (_d = (_c = config.writer).init) == null ? void 0 : _d.call(_c)]);
    return new _AllureStore(config);
  }
  static async fromDirectory(resultsDirectory, config = {}) {
    const reader = new FileAllureReader({ resultsDirectory, onError: config.onError });
    const writer = new FileAllureWriter({ resultsDirectory, onError: config.onError, overwrite: config.overwrite });
    return _AllureStore.fromConfig({ reader, writer });
  }
  //#region Reading methods
  async getAllResults() {
    const [containerIds, resultIds] = await Promise.all([
      this.#reader.getContainerIds(),
      this.#reader.getResultIds()
    ]);
    const containerMap = await this.#buildContainerMap(containerIds);
    const rawResults = await Promise.all(resultIds.map((id) => this.#reader.readResult(id)));
    const validResults = rawResults.filter((r) => r != null);
    return validResults.map((result) => this.#mergeContainers(result, containerMap));
  }
  async getLatestResults() {
    const all = await this.getAllResults();
    const map = /* @__PURE__ */ new Map();
    for (const result of all) {
      const existing = map.get(result.historyId);
      if (!existing || result.stop > existing.stop) {
        map.set(result.historyId, result);
      }
    }
    return [...map.values()];
  }
  async getCategories() {
    return this.#reader.readCategories();
  }
  async getEnvironment() {
    return this.#reader.readEnvironmentInfo();
  }
  async getExecutor() {
    return this.#reader.readExecutorInfo();
  }
  async getContainer(id) {
    return this.#reader.readContainer(id);
  }
  async getResult(id) {
    return this.#reader.readResult(id);
  }
  //#endregion
  //#region Writing methods
  async writeCategories(categories) {
    return this.#writer.writeCategories(categories);
  }
  async writeEnvironmentInfo(info) {
    return this.#writer.writeEnvironmentInfo(info);
  }
  async writeExecutorInfo(info) {
    return this.#writer.writeExecutorInfo(info);
  }
  async writeResult(result) {
    return this.#writer.writeResult(result);
  }
  async writeContainer(container) {
    return this.#writer.writeContainer(container);
  }
  //#endregion
  //#region Private helper methods
  async #buildContainerMap(containerIds) {
    const containerMap = /* @__PURE__ */ new Map();
    await Promise.all(
      containerIds.map(async (cid) => {
        const container = await this.#reader.readContainer(cid);
        if (container) {
          containerMap.set(container.uuid, container);
        }
      })
    );
    return containerMap;
  }
  #mergeContainers(result, containerMap) {
    const ancestors = this.#findAncestorContainers(result.uuid, containerMap);
    const merged = { ...result, steps: this.#mergeSteps(result, ancestors) };
    return merged;
  }
  #findAncestorContainers(startId, containerMap) {
    const parentFor = /* @__PURE__ */ new Map();
    for (const container of containerMap.values()) {
      for (const child of container.children) {
        parentFor.set(child, container.uuid);
      }
    }
    const ancestors = [];
    let currentId = startId;
    while (currentId) {
      const parentId = parentFor.get(currentId);
      if (!parentId) break;
      const parentContainer = containerMap.get(parentId);
      if (!parentContainer) break;
      ancestors.push(parentContainer);
      currentId = parentId;
    }
    return ancestors.reverse();
  }
  #mergeSteps(result, ancestors) {
    const beforeSteps = ancestors.flatMap((a) => a.befores ?? []);
    const afterSteps = [...ancestors].reverse().flatMap((a) => a.afters ?? []);
    return [...beforeSteps, ...result.steps ?? [], ...afterSteps];
  }
  //#endregion
};

// src/index.ts
async function fromConfig(options) {
  return AllureStore.fromConfig(options);
}
async function fromDirectory(resultsDirectory, options) {
  return AllureStore.fromDirectory(resultsDirectory, options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AllureStore,
  FileAllureReader,
  FileAllureWriter,
  fromConfig,
  fromDirectory
});
//# sourceMappingURL=index.js.map
