"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestEntryMetadata = void 0;
const tslib_1 = require("tslib");
const symbols = tslib_1.__importStar(require("../symbols"));
const BaseMetadata_1 = require("./BaseMetadata");
class TestEntryMetadata extends BaseMetadata_1.BaseMetadata {
    describeBlock;
    invocations = [];
    constructor(context, describeBlock, id) {
        super(context, id);
        this.describeBlock = describeBlock;
    }
    get lastInvocation() {
        return this.invocations[this.invocations.length - 1];
    }
    get file() {
        return this.describeBlock.file;
    }
    *ancestors() {
        yield this.describeBlock;
        yield* this.describeBlock.ancestors();
    }
    *allAncestors() {
        yield this.describeBlock;
        yield* this.describeBlock.allAncestors();
    }
    [symbols.start]() {
        const id = this[symbols.id].nest(`${this.invocations.length}`);
        const invocation = this[symbols.context].factory.createTestInvocationMetadata(this, id);
        this.invocations.push(invocation);
        this.describeBlock[symbols.pushExecution](invocation);
        const file = this.describeBlock.file;
        file[symbols.currentMetadata] = invocation;
        file[symbols.lastTestEntry] = this;
        return invocation;
    }
    [symbols.finish](skipped = false) {
        const file = this.describeBlock.file;
        const lastInvocation = this.invocations[this.invocations.length - 1];
        if (!lastInvocation) {
            throw new Error('Cannot finish test entry without any invocations');
        }
        file[symbols.currentMetadata] = this.describeBlock;
        if (!skipped) {
            file[symbols.reportedTestEntries].push(this);
        }
    }
}
exports.TestEntryMetadata = TestEntryMetadata;
//# sourceMappingURL=TestEntryMetadata.js.map