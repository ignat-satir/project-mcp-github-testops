"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testCase = void 0;
const tslib_1 = require("tslib");
const common_1 = require("../common");
const custom = tslib_1.__importStar(require("../custom"));
const utils_1 = require("../../utils");
exports.testCase = {
    ignored: () => false,
    historyId: ({ testCaseMetadata, result }) => testCaseMetadata.historyId ?? result.fullName,
    displayName: ({ testCase, testCaseMetadata }) => testCaseMetadata.displayName ?? testCase.title,
    fullName: ({ testCase, testCaseMetadata }) => testCaseMetadata.fullName ?? testCase.fullName,
    description: ({ testCaseMetadata }) => testCaseMetadata.description?.join('\n\n') ?? '',
    descriptionHtml: ({ testCaseMetadata }) => testCaseMetadata.descriptionHtml?.join('\n') ?? '',
    start: ({ testCase, testCaseMetadata }) => testCaseMetadata.start ?? (testCaseMetadata.stop ?? Date.now()) - (testCase.duration ?? 0),
    stop: ({ testCaseMetadata }) => testCaseMetadata.stop ?? Date.now(),
    stage: ({ testCase, testCaseMetadata }) => testCaseMetadata.stage ?? getTestCaseStage(testCase),
    status: ({ testCase, testCaseMetadata }) => testCaseMetadata.status ?? getTestCaseStatus(testCase),
    statusDetails: ({ $, testCase, testCaseMetadata }) => $.stripAnsi(testCaseMetadata.statusDetails ??
        (0, utils_1.getStatusDetails)((testCase.failureMessages ?? []).join('\n'))),
    attachments: ({ testCaseMetadata }) => testCaseMetadata.attachments ?? [],
    parameters: ({ testCaseMetadata }) => testCaseMetadata.parameters ?? [],
    labels: (0, common_1.compose2)(custom.labels({
        suite: ({ testCase, filePath }) => testCase.ancestorTitles[0] ?? filePath.at(-1),
        subSuite: ({ testCase }) => testCase.ancestorTitles.slice(1).join(' '),
    }), ({ testCaseMetadata }) => testCaseMetadata.labels ?? []),
    links: ({ testCaseMetadata }) => testCaseMetadata.links ?? [],
};
function getTestCaseStatus(testCase) {
    const hasErrors = testCase.failureMessages?.length > 0;
    const hasBuiltinErrors = hasErrors && testCase.failureMessages.some(looksLikeBroken);
    switch (testCase.status) {
        case 'passed': {
            return 'passed';
        }
        case 'failed': {
            return hasBuiltinErrors ? 'broken' : 'failed';
        }
        case 'skipped': {
            return 'skipped';
        }
        case 'pending':
        case 'todo':
        case 'disabled': {
            return 'skipped';
        }
        case 'focused': {
            return hasErrors ? 'failed' : 'passed';
        }
        default: {
            return 'unknown';
        }
    }
}
function looksLikeBroken(errorMessage) {
    return errorMessage
        ? errorMessage.startsWith('Error: \n') ||
            errorMessage.startsWith('EvalError:') ||
            errorMessage.startsWith('RangeError:') ||
            errorMessage.startsWith('ReferenceError:') ||
            errorMessage.startsWith('SyntaxError:') ||
            errorMessage.startsWith('TypeError:') ||
            errorMessage.startsWith('URIError:') ||
            errorMessage.startsWith('AggregateError:') ||
            errorMessage.startsWith('InternalError:') ||
            errorMessage.startsWith('AllureRuntimeError:') ||
            errorMessage.startsWith('AllureReporterError:')
        : true;
}
function getTestCaseStage(testCase) {
    switch (testCase.status) {
        case 'passed':
        case 'focused': {
            return 'finished';
        }
        case 'todo':
        case 'disabled':
        case 'pending':
        case 'skipped': {
            return 'pending';
        }
        default: {
            return 'interrupted';
        }
    }
}
//# sourceMappingURL=testCase.js.map