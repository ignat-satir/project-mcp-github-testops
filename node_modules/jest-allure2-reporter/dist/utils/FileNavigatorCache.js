"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileNavigatorCache = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const promises_1 = tslib_1.__importDefault(require("node:fs/promises"));
const logger_1 = require("../logger");
const index_1 = require("./index");
class FileNavigatorCache {
    #cache = new Map();
    #scannedSourcemaps = new Set();
    resolve = (filePath) => {
        const absolutePath = node_path_1.default.isAbsolute(filePath) ? filePath : node_path_1.default.resolve(filePath);
        if (!this.#cache.has(absolutePath)) {
            this.#cache.set(absolutePath, this.#createNavigator(absolutePath));
        }
        return this.#cache.get(absolutePath);
    };
    hasScannedSourcemap = (filePath) => {
        const sourceMapPath = `${filePath}.map`;
        return this.#scannedSourcemaps.has(sourceMapPath);
    };
    scanSourcemap = async (filePath) => {
        if (this.hasScannedSourcemap(filePath))
            return;
        const sourceMapPath = `${filePath}.map`;
        this.#scannedSourcemaps.add(sourceMapPath);
        const doesNotExist = await promises_1.default.access(sourceMapPath).catch(() => true);
        if (doesNotExist)
            return;
        const sourceMapRaw = await promises_1.default.readFile(sourceMapPath, 'utf8').catch((error) => {
            logger_1.log.error(error, `Failed to read sourcemap for: ${filePath}`);
        });
        if (sourceMapRaw == null)
            return;
        let sourceMap;
        try {
            sourceMap = JSON.parse(sourceMapRaw);
        }
        catch (error) {
            logger_1.log.error(error, `Failed to parse sourcemap for: ${filePath}`);
        }
        if (!sourceMap)
            return;
        const { sourceRoot, sources, sourcesContent } = sourceMap;
        if (!sources || !sourcesContent)
            return;
        const baseDirectory = sourceRoot && node_path_1.default.isAbsolute(sourceRoot) ? sourceRoot : node_path_1.default.dirname(filePath);
        for (const [index, content] of sourcesContent.entries()) {
            const source = sources[index];
            if (!content || !source)
                continue;
            const sourcePath = node_path_1.default.isAbsolute(source) ? source : node_path_1.default.resolve(baseDirectory, source);
            if (this.#cache.has(sourcePath))
                continue;
            const navigator = new index_1.FileNavigator(content);
            this.#cache.set(sourcePath, Promise.resolve(navigator));
        }
    };
    #createNavigator = async (filePath) => {
        const sourceCode = await promises_1.default.readFile(filePath, 'utf8').catch(() => void 0);
        return sourceCode == null ? undefined : new index_1.FileNavigator(sourceCode);
    };
    clear() {
        this.#cache.clear();
    }
    static instance = new FileNavigatorCache();
}
exports.FileNavigatorCache = FileNavigatorCache;
//# sourceMappingURL=FileNavigatorCache.js.map